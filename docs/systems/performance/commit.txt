commit a495638e6a75033d16c99b2c491bc686c36140b9
Author: Seb <sebgrubb@gmail.com>
Date:   Wed Dec 3 08:36:53 2025 -0500

    Add unified GameRenderer and GBA-accurate game loop
    
    Introduces GameRenderer component with automatic WebGL/Canvas2D backend selection, shared game logic, and extracted hooks for rendering and game state. Adds useGameLoop hook for GBA-accurate frame timing. Refactors PlayerController and Surfing logic for frame-rate independence and correct state reset on warps. Updates DebugPanel with map selection tab and enhanced info. Deprecates legacy WebGLMapPage routing in favor of GameRenderer.

diff --git a/docs/projects/webglrefactor/10-architecture-parity-map.md b/docs/projects/webglrefactor/10-architecture-parity-map.md
index eebf0808..0a648cf3 100644
--- a/docs/projects/webglrefactor/10-architecture-parity-map.md
+++ b/docs/projects/webglrefactor/10-architecture-parity-map.md
@@ -3,7 +3,7 @@
 This document tracks the effort to merge `src/pages/WebGLMapPage.tsx` and `src/components/MapRenderer.tsx` into a unified `GameRenderer` component with pluggable WebGL/Canvas2D backends.
 
 > **Last Updated:** 2025-12-02
-> **Status:** Phase 1 in progress - extracting shared utilities
+> **Status:** Phase 6 nearly complete - GameRenderer has full WebGL implementation, Canvas2D path pending
 
 ## OKR: Unified Renderer Architecture
 
@@ -526,54 +526,44 @@ Define clean interfaces for rendering backends.
 
 Replace per-file logic with shared hooks.
 
-- [~] **5.0** Extract WebGL render loop to reduce WebGLMapPage.tsx size ⏳ IN PROGRESS
-  - [x] Created `src/hooks/useWebGLSpriteBuilder.ts` (~320 lines)
+- [x] **5.0** Extract WebGL render loop to reduce WebGLMapPage.tsx size ✅ DONE (2025-12-02)
+  - [x] Created `src/hooks/useWebGLSpriteBuilder.ts` (357 lines)
     - Extracts sprite building: player, NPCs, field effects, doors, arrows
     - Returns sorted sprite batches ready for compositing
-  - [x] Created `src/rendering/compositeWebGLFrame.ts` (~230 lines)
+  - [x] Created `src/rendering/compositeWebGLFrame.ts` (252 lines)
     - Extracts layer compositing logic
     - Handles reflection layer splitting, water masks, priority batches
-  - [ ] Integrate extracted code into WebGLMapPage.tsx
-    - Replace inline sprite building with useWebGLSpriteBuilder
-    - Replace inline compositing with compositeWebGLFrame
-  - [ ] Keep WebGLMapPage as thin orchestrator (~500-600 lines)
-  - [ ] **TARGET:** Reduce WebGLMapPage from 1831 to ~600 lines
-  - [ ] **TEST:** No visual regression in WebGL mode
-
-- [ ] **5.1** Create `src/hooks/useGameLoop.ts`
-  - [ ] GBA-accurate frame timing (59.7275 Hz)
-  - [ ] Shimmer animation updates
-  - [ ] Returns: `{ gbaFrame, deltaTime, shimmerState }`
-  - [ ] **PARITY:** Both renderers use shared hook
-  - [ ] **TEST:** Frame timing matches GBA
-
-- [ ] **5.2** Create `src/hooks/usePlayerUpdate.ts`
-  - [ ] Input handling
-  - [ ] Movement updates
-  - [ ] Tile change detection
-  - [ ] Returns: `{ player, tileChanged, currentTile }`
-  - [ ] **PARITY:** Both renderers use shared hook
-  - [ ] **TEST:** Player movement works
-
-- [ ] **5.3** Create `src/hooks/useSceneComposition.ts`
-  - [ ] Sprite batch building (player, NPCs, effects)
-  - [ ] Layer sorting
-  - [ ] Reflection handling
-  - [ ] Returns: `{ sprites, reflectionSprites, priority0Sprites }`
-  - [ ] **PARITY:** Both renderers use shared hook
-  - [ ] **TEST:** Sprite ordering correct
-
-- [ ] **5.4** Migrate WebGLMapPage to use new hooks
-  - [ ] Replace inline logic with hook calls
-  - [ ] Verify no visual regression
-  - [ ] **PARITY:** WebGLMapPage uses unified hooks
-  - [ ] **TEST:** Full playthrough in WebGL mode
-
-- [ ] **5.5** Migrate MapRenderer to use new hooks
-  - [ ] Replace/merge existing hooks
-  - [ ] Verify no visual regression
-  - [ ] **PARITY:** MapRenderer uses unified hooks
-  - [ ] **TEST:** Full playthrough in Canvas2D mode
+  - [x] Integrated extracted code into WebGLMapPage.tsx
+    - Replaced inline sprite building with `buildSprites()` from useWebGLSpriteBuilder
+    - Replaced inline compositing with `compositeWebGLFrame()`
+    - Cleaned up ~15 unused imports
+  - [x] **RESULT:** WebGLMapPage reduced from 1835 to 1467 lines (368 lines removed)
+  - [x] **TEST:** Build passes, no visual regression in WebGL mode
+
+- [x] **5.1** Create `src/hooks/useGameLoop.ts` ✅ DONE (2025-12-02)
+  - [x] GBA-accurate frame timing (59.7275 Hz)
+  - [x] Shimmer animation updates via `getGlobalShimmer().update()`
+  - [x] Returns: `{ gbaFrame, animationFrame, deltaTime, timestamp, animationFrameChanged }`
+  - [x] **PARITY:** Available for both renderers
+  - [x] **TEST:** Build passes
+
+- [x] **5.2** Existing `useRunUpdate` hook ✅ ALREADY EXISTS
+  - [x] Already handles player updates, warp detection, camera, etc.
+  - [x] Used by Canvas2D renderer (MapRenderer)
+  - [x] **Note:** WebGLMapPage has inline version, will be unified in Phase 6
+
+- [x] **5.3** Existing `useCompositeScene` hook ✅ ALREADY EXISTS
+  - [x] Already handles sprite batch building, layer sorting
+  - [x] Used by Canvas2D renderer (MapRenderer)
+  - [x] **Note:** WebGL uses `compositeWebGLFrame`, both achieve same result
+
+- [ ] **5.4** Migrate WebGLMapPage to use unified hooks
+  - [ ] Deferred to Phase 6 - GameRenderer will use unified hooks
+  - [ ] WebGLMapPage will be deprecated once GameRenderer is complete
+
+- [ ] **5.5** Migrate MapRenderer to use unified hooks
+  - [ ] Deferred to Phase 6 - GameRenderer will use unified hooks
+  - [ ] MapRenderer will be deprecated once GameRenderer is complete
 
 ---
 
@@ -581,26 +571,26 @@ Replace per-file logic with shared hooks.
 
 Final unification step - **OKR completion checkpoint**.
 
-- [ ] **6.1** Create `src/components/GameRenderer.tsx`
-  - [ ] Detect WebGL2 support on mount
-  - [ ] Instantiate appropriate pipeline + sprite renderer
-  - [ ] Use unified hooks for game logic
-  - [ ] Single render loop calling renderer interfaces
-  - [ ] **PARITY:** Single component serves both backends
-
-- [ ] **6.2** Create renderer factory
-  ```typescript
-  function createRenderers(canvas: HTMLCanvasElement): {
-    pipeline: IRenderPipeline;
-    spriteRenderer: ISpriteRenderer;
-    fadeRenderer: IFadeRenderer;
-  }
-  ```
-
-- [ ] **6.3** Wire up routing
-  - [ ] `/#/play` → GameRenderer (auto-detect backend)
-  - [ ] `/#/play?renderer=webgl` → Force WebGL
-  - [ ] `/#/play?renderer=canvas2d` → Force Canvas2D
+- [x] **6.1** Create `src/components/GameRenderer.tsx` ✅ DONE (2025-12-02)
+  - [x] Detect WebGL2 support on mount via `detectRendererType()`
+  - [x] Instantiate appropriate pipeline + sprite + fade renderers via `RendererFactory`
+  - [x] Use `useGameLoop` hook for GBA-accurate timing
+  - [x] Full WebGL rendering implementation with player, NPCs, field effects, doors, arrows
+  - [x] Full game logic: player updates, warp detection, camera following
+  - [x] Uses extracted hooks: `useWebGLSpriteBuilder`, `compositeWebGLFrame`
+  - [ ] **TODO:** Canvas2D rendering path (placeholder only)
+
+- [x] **6.2** Create `src/rendering/RendererFactory.ts` ✅ DONE (2025-12-02)
+  - [x] `createRenderers()` - creates complete renderer set
+  - [x] `detectRendererType()` - auto-detect WebGL/Canvas2D
+  - [x] `getRendererTypeFromURL()` - read `?renderer=` param
+  - [x] Returns: `{ pipeline, spriteRenderer, fadeRenderer, webglCanvas, dispose }`
+
+- [x] **6.3** Wire up routing ✅ DONE (2025-12-02)
+  - [x] `/#/play` → GameRenderer (auto-detect backend)
+  - [x] `/#/play?renderer=webgl` → Force WebGL
+  - [x] `/#/play?renderer=canvas2d` → Force Canvas2D
+  - [x] Added to `src/main.tsx` Router
 
 - [ ] **6.4** Deprecate old components
   - [ ] Mark WebGLMapPage as deprecated
@@ -608,6 +598,7 @@ Final unification step - **OKR completion checkpoint**.
   - [ ] Add console warnings if accessed directly
 
 - [ ] **6.5** Final cleanup & OKR verification
+  - [ ] Complete GameRenderer rendering implementation
   - [ ] Remove duplicate code
   - [ ] Update documentation
   - [ ] **MEASURE:** Count final LOC - target <1800 combined (down from ~3000)
diff --git a/src/components/GameRenderer.tsx b/src/components/GameRenderer.tsx
new file mode 100644
index 00000000..b54f74e3
--- /dev/null
+++ b/src/components/GameRenderer.tsx
@@ -0,0 +1,622 @@
+/**
+ * GameRenderer - Unified game rendering component
+ *
+ * Automatically selects WebGL or Canvas2D backend based on browser capabilities.
+ * Uses shared game logic for both backends.
+ */
+
+import { useEffect, useRef, useState, useCallback, forwardRef, useImperativeHandle } from 'react';
+import { createRenderers, detectRendererType, getRendererTypeFromURL, type RendererSet, type RendererType } from '../rendering/RendererFactory';
+import { WorldManager, type WorldSnapshot } from '../game/WorldManager';
+import { PlayerController } from '../game/PlayerController';
+import { CameraController, createWebGLCameraController } from '../game/CameraController';
+import { ObjectEventManager } from '../game/ObjectEventManager';
+import { WarpHandler } from '../field/WarpHandler';
+import { FadeController } from '../field/FadeController';
+import { TileResolverFactory } from '../game/TileResolverFactory';
+import { useGameLoop, type GameFrameState } from '../hooks/useGameLoop';
+import { useDoorAnimations } from '../hooks/useDoorAnimations';
+import { useArrowOverlay } from '../hooks/useArrowOverlay';
+import { useDoorSequencer } from '../hooks/useDoorSequencer';
+import { useFieldSprites } from '../hooks/useFieldSprites';
+import { useWebGLSpriteBuilder } from '../hooks/useWebGLSpriteBuilder';
+import { compositeWebGLFrame } from '../rendering/compositeWebGLFrame';
+import { uploadTilesetsFromSnapshot } from '../rendering/webgl/TilesetUploader';
+import { buildWorldCameraView } from '../game/buildWorldCameraView';
+import { findPlayerSpawnPosition } from '../game/findPlayerSpawnPosition';
+import { setupObjectCollisionChecker } from '../game/setupObjectCollisionChecker';
+import { processWarpTrigger, updateWarpHandlerTile } from '../game/WarpTriggerProcessor';
+import { getPlayerAtlasName, getFieldEffectAtlasName, getNPCAtlasName } from '../rendering/spriteUtils';
+import { computeReflectionState, type ReflectionMetaProvider } from '../field/ReflectionRenderer';
+import { getReflectionMetaFromSnapshot, buildTilesetRuntimesForSnapshot, createRenderContextFromSnapshot } from '../game/snapshotUtils';
+import { npcSpriteCache } from '../game/npc/NPCSpriteLoader';
+import { resolveTileAt } from '../components/map/utils';
+import { DEFAULT_VIEWPORT_CONFIG, getViewportPixelSize } from '../config/viewport';
+import { METATILE_SIZE } from '../utils/mapLoader';
+import { DebugPanel, DEFAULT_DEBUG_OPTIONS, type DebugOptions, type DebugState } from './debug';
+import { DialogBox, useDialog } from './dialog';
+import type { ReflectionState } from './map/types';
+import type { TilesetRuntime as TilesetRuntimeType } from '../utils/tilesetUtils';
+import type { WebGLSpriteRenderer } from '../rendering/webgl/WebGLSpriteRenderer';
+import type { CardinalDirection } from '../field/types';
+import type { RenderContext } from '../rendering/types';
+
+export interface GameRendererProps {
+  mapId: string;
+  mapName?: string;
+  zoom?: number;
+  forceRenderer?: RendererType;
+}
+
+export interface GameRendererHandle {
+  getPlayerPosition: () => { tileX: number; tileY: number; direction: string; mapId: string } | null;
+  getRendererType: () => RendererType;
+}
+
+const VIEWPORT_CONFIG = DEFAULT_VIEWPORT_CONFIG;
+const VIEWPORT_PIXEL_SIZE = getViewportPixelSize(VIEWPORT_CONFIG);
+
+export const GameRenderer = forwardRef<GameRendererHandle, GameRendererProps>(({
+  mapId,
+  mapName = 'Unknown Map',
+  zoom = 1,
+  forceRenderer,
+}, ref) => {
+  // Canvas ref
+  const canvasRef = useRef<HTMLCanvasElement>(null);
+
+  // Renderer state
+  const [rendererType, setRendererType] = useState<RendererType | null>(null);
+  const [loading, setLoading] = useState(true);
+  const [error, setError] = useState<string | null>(null);
+  const renderersRef = useRef<RendererSet | null>(null);
+
+  // Game state refs
+  const worldManagerRef = useRef<WorldManager | null>(null);
+  const worldSnapshotRef = useRef<WorldSnapshot | null>(null);
+  const worldBoundsRef = useRef<{ width: number; height: number; minX: number; minY: number }>({ width: 0, height: 0, minX: 0, minY: 0 });
+  const playerRef = useRef<PlayerController | null>(null);
+  const cameraRef = useRef<CameraController | null>(null);
+  const objectEventManagerRef = useRef<ObjectEventManager>(new ObjectEventManager());
+  const warpHandlerRef = useRef<WarpHandler>(new WarpHandler());
+  const fadeControllerRef = useRef<FadeController>(new FadeController());
+  const tilesetRuntimesRef = useRef<Map<string, TilesetRuntimeType>>(new Map());
+  const playerLoadedRef = useRef(false);
+  const playerHiddenRef = useRef(false);
+  const tilesetsUploadedRef = useRef(false);
+  const fieldSpritesLoadedRef = useRef(false);
+  const doorSpritesUploadedRef = useRef<Set<string>>(new Set());
+  const arrowSpriteUploadedRef = useRef(false);
+
+  // Debug state
+  const [debugOptions, setDebugOptions] = useState<DebugOptions>(DEFAULT_DEBUG_OPTIONS);
+  const [debugState] = useState<DebugState>({
+    player: null,
+    tile: null,
+    objectsAtPlayerTile: null,
+    objectsAtFacingTile: null,
+    adjacentObjects: null,
+    allVisibleNPCs: [],
+    allVisibleItems: [],
+    totalNPCCount: 0,
+    totalItemCount: 0,
+  });
+
+  // Hooks
+  const doorAnimations = useDoorAnimations();
+  const arrowOverlay = useArrowOverlay();
+  const fieldSprites = useFieldSprites();
+  const doorSequencer = useDoorSequencer({ warpHandler: warpHandlerRef.current });
+  useDialog();
+  const { buildSprites } = useWebGLSpriteBuilder();
+
+  // Expose handle
+  useImperativeHandle(ref, () => ({
+    getPlayerPosition: () => {
+      const player = playerRef.current;
+      const snapshot = worldSnapshotRef.current;
+      if (!player || !snapshot) return null;
+      return {
+        tileX: player.tileX,
+        tileY: player.tileY,
+        direction: player.dir,
+        mapId: snapshot.anchorMapId,
+      };
+    },
+    getRendererType: () => rendererType ?? 'canvas2d',
+  }), [rendererType]);
+
+  // Get RenderContext from snapshot for tile resolution
+  const getRenderContextFromSnapshot = useCallback((snapshot: WorldSnapshot): RenderContext | null => {
+    return createRenderContextFromSnapshot(snapshot, tilesetRuntimesRef.current);
+  }, []);
+
+  // Compute reflection state from snapshot
+  const computeReflectionStateFromSnapshot = useCallback((
+    snapshot: WorldSnapshot,
+    tileX: number,
+    tileY: number,
+    prevTileX: number,
+    prevTileY: number,
+    spriteWidth: number = 16,
+    spriteHeight: number = 32
+  ): ReflectionState => {
+    const metaProvider: ReflectionMetaProvider = (x, y) =>
+      getReflectionMetaFromSnapshot(snapshot, tilesetRuntimesRef.current, x, y);
+
+    return computeReflectionState(metaProvider, tileX, tileY, prevTileX, prevTileY, spriteWidth, spriteHeight);
+  }, []);
+
+  // Load object events from snapshot
+  const loadObjectEventsFromSnapshot = useCallback(async (snapshot: WorldSnapshot, spriteRenderer: WebGLSpriteRenderer | null): Promise<void> => {
+    const objectManager = objectEventManagerRef.current;
+
+    // Clear previous objects
+    objectManager.clear();
+
+    // Parse object events for each map in the snapshot
+    for (const mapInst of snapshot.maps) {
+      if (mapInst.objectEvents.length > 0) {
+        objectManager.parseMapObjects(
+          mapInst.entry.id,
+          mapInst.objectEvents,
+          mapInst.offsetX,
+          mapInst.offsetY
+        );
+      }
+    }
+
+    // Get unique graphics IDs needed for NPCs
+    const graphicsIds = objectManager.getUniqueNPCGraphicsIds();
+    if (graphicsIds.length === 0) return;
+
+    // Load sprites that haven't been loaded yet
+    await npcSpriteCache.loadMany(graphicsIds);
+
+    // Upload loaded sprites to WebGL renderer
+    if (spriteRenderer) {
+      for (const graphicsId of graphicsIds) {
+        const sprite = npcSpriteCache.get(graphicsId);
+        if (sprite) {
+          const atlasName = getNPCAtlasName(graphicsId);
+          const dims = npcSpriteCache.getDimensions(graphicsId);
+          spriteRenderer.uploadSpriteSheet(atlasName, sprite, {
+            frameWidth: dims.frameWidth,
+            frameHeight: dims.frameHeight,
+          });
+        }
+      }
+    }
+  }, []);
+
+  // Initialize renderers and game
+  useEffect(() => {
+    const canvas = canvasRef.current;
+    if (!canvas) return;
+
+    let disposed = false;
+
+    const init = async () => {
+      try {
+        // Determine renderer type preference
+        const urlType = getRendererTypeFromURL();
+        const preferredType = forceRenderer ?? urlType ?? detectRendererType();
+
+        // Create renderers (may fallback to Canvas2D if WebGL fails)
+        const renderers = createRenderers({
+          viewportWidth: VIEWPORT_PIXEL_SIZE.width,
+          viewportHeight: VIEWPORT_PIXEL_SIZE.height,
+          forceType: preferredType,
+        });
+        if (disposed) return;
+        renderersRef.current = renderers;
+
+        // Set actual renderer type (may differ from preferred if WebGL failed)
+        setRendererType(renderers.type);
+
+        // Create world manager
+        const worldManager = new WorldManager();
+        worldManagerRef.current = worldManager;
+
+        // Initialize world
+        const snapshot = await worldManager.initialize(mapId);
+        if (disposed) return;
+        worldSnapshotRef.current = snapshot;
+
+        // Update world bounds
+        const bounds = snapshot.worldBounds;
+        worldBoundsRef.current = {
+          width: bounds.width * METATILE_SIZE,
+          height: bounds.height * METATILE_SIZE,
+          minX: bounds.minX,
+          minY: bounds.minY,
+        };
+
+        // Build tileset runtimes for reflection detection
+        buildTilesetRuntimesForSnapshot(snapshot, tilesetRuntimesRef.current);
+
+        // Upload tilesets for WebGL
+        if (renderers.type === 'webgl' && renderers.getWebGLPipeline) {
+          const pipeline = renderers.getWebGLPipeline();
+          const resolver = TileResolverFactory.fromSnapshot(snapshot);
+          pipeline.setTileResolver(resolver);
+          uploadTilesetsFromSnapshot(pipeline, snapshot);
+          tilesetsUploadedRef.current = true;
+        }
+
+        // Create player
+        const player = new PlayerController();
+        playerRef.current = player;
+
+        // Set up tile resolver for player collision
+        const playerResolver = TileResolverFactory.createPlayerResolver(snapshot);
+        player.setTileResolver(playerResolver);
+
+        // Set up object collision checker
+        setupObjectCollisionChecker(player, objectEventManagerRef.current);
+
+        // Create camera
+        const camera = createWebGLCameraController(
+          VIEWPORT_CONFIG.tilesWide,
+          VIEWPORT_CONFIG.tilesHigh
+        );
+        cameraRef.current = camera;
+
+        // Find spawn position
+        const anchorMap = snapshot.maps.find(m => m.entry.id === mapId);
+        if (anchorMap) {
+          // Build behavior provider
+          const renderContext = getRenderContextFromSnapshot(snapshot);
+          const getBehavior = (x: number, y: number): number => {
+            if (!renderContext) return 0;
+            const resolved = resolveTileAt(renderContext, anchorMap.offsetX + x, anchorMap.offsetY + y);
+            return resolved?.attributes?.behavior ?? 0;
+          };
+
+          const spawnResult = findPlayerSpawnPosition(
+            anchorMap.mapData,
+            anchorMap.warpEvents,
+            getBehavior
+          );
+
+          const spawnX = anchorMap.offsetX + spawnResult.x;
+          const spawnY = anchorMap.offsetY + spawnResult.y;
+          player.setPosition(spawnX * METATILE_SIZE, spawnY * METATILE_SIZE);
+        }
+
+        // Load player sprites
+        await player.loadSprite('walking', '/pokeemerald/graphics/object_events/pics/people/brendan/walking.png');
+        await player.loadSprite('running', '/pokeemerald/graphics/object_events/pics/people/brendan/running.png');
+        await player.loadSprite('surfing', '/pokeemerald/graphics/object_events/pics/people/brendan/surfing.png');
+        await player.loadSprite('shadow', '/pokeemerald/graphics/field_effects/pics/shadow_medium.png');
+        if (disposed) return;
+
+        // Upload player sprites for WebGL
+        if (renderers.type === 'webgl') {
+          const spriteRenderer = renderers.spriteRenderer as WebGLSpriteRenderer;
+
+          // Upload all loaded player sprite sheets
+          const spriteSheets = player.getSpriteSheets();
+          for (const [key, canvas] of spriteSheets) {
+            const atlasName = getPlayerAtlasName(key);
+            spriteRenderer.uploadSpriteSheet(atlasName, canvas);
+          }
+
+          // Load and upload object events (NPCs)
+          await loadObjectEventsFromSnapshot(snapshot, spriteRenderer);
+        }
+
+        // Load field sprites
+        await fieldSprites.loadAll();
+        if (disposed) return;
+
+        // Upload field sprites for WebGL
+        if (renderers.type === 'webgl') {
+          const spriteRenderer = renderers.spriteRenderer as WebGLSpriteRenderer;
+          const fieldSpriteKeys = ['grass', 'longGrass', 'sand', 'splash', 'ripple'] as const;
+          for (const key of fieldSpriteKeys) {
+            const canvas = fieldSprites.sprites[key];
+            if (canvas) {
+              const atlasName = getFieldEffectAtlasName(key);
+              spriteRenderer.uploadSpriteSheet(atlasName, canvas);
+            }
+          }
+          fieldSpritesLoadedRef.current = true;
+        }
+
+        playerLoadedRef.current = true;
+        setLoading(false);
+      } catch (err) {
+        if (!disposed) {
+          setError(err instanceof Error ? err.message : 'Failed to initialize game');
+          setLoading(false);
+        }
+      }
+    };
+
+    init();
+
+    return () => {
+      disposed = true;
+      renderersRef.current?.dispose();
+      renderersRef.current = null;
+      worldManagerRef.current?.dispose();
+      worldManagerRef.current = null;
+      playerRef.current?.destroy();
+      playerRef.current = null;
+    };
+  }, [mapId, forceRenderer, fieldSprites, getRenderContextFromSnapshot, loadObjectEventsFromSnapshot]);
+
+  // Game update function
+  const handleUpdate = useCallback((deltaMs: number, timestamp: number) => {
+    const player = playerRef.current;
+    const snapshot = worldSnapshotRef.current;
+    if (!player || !playerLoadedRef.current || !snapshot) return;
+
+    // Update player
+    player.update(deltaMs);
+
+    // Update warp handler cooldown
+    warpHandlerRef.current.update(deltaMs);
+
+    // Prune door animations
+    doorAnimations.prune(timestamp);
+
+    // Update camera to follow player
+    const camera = cameraRef.current;
+    if (camera) {
+      const { minX, minY } = worldBoundsRef.current;
+      const bounds = snapshot.worldBounds;
+      camera.setBounds({
+        minX: minX * METATILE_SIZE,
+        minY: minY * METATILE_SIZE,
+        width: bounds.width * METATILE_SIZE,
+        height: bounds.height * METATILE_SIZE,
+      });
+      camera.followTarget(player);
+    }
+
+    // Check for warps
+    const renderContext = getRenderContextFromSnapshot(snapshot);
+    if (renderContext) {
+      const warpResult = processWarpTrigger({
+        player,
+        renderContext,
+        warpHandler: warpHandlerRef.current,
+        isDoorSequencerActive: doorSequencer.isActive(),
+      });
+
+      if (warpResult.tileChanged) {
+        updateWarpHandlerTile(warpHandlerRef.current, warpResult);
+      }
+
+      // Update arrow overlay based on current tile behavior
+      if (!warpHandlerRef.current.isInProgress()) {
+        const resolved = resolveTileAt(renderContext, player.tileX, player.tileY);
+        const behavior = resolved?.attributes?.behavior ?? 0;
+        arrowOverlay.update(
+          player.dir as CardinalDirection,
+          player.tileX,
+          player.tileY,
+          behavior,
+          timestamp,
+          doorSequencer.isActive()
+        );
+      }
+    }
+  }, [doorAnimations, arrowOverlay, doorSequencer, getRenderContextFromSnapshot]);
+
+  // Game render function
+  const handleRender = useCallback((state: GameFrameState) => {
+    const canvas = canvasRef.current;
+    const renderers = renderersRef.current;
+    const player = playerRef.current;
+    const snapshot = worldSnapshotRef.current;
+
+    if (!canvas || !renderers || !player || !snapshot || !playerLoadedRef.current) {
+      if (state.gbaFrame % 60 === 0) {
+        console.log('[RENDER] Skipping - missing:', {
+          canvas: !!canvas,
+          renderers: !!renderers,
+          player: !!player,
+          snapshot: !!snapshot,
+          playerLoaded: playerLoadedRef.current,
+        });
+      }
+      return;
+    }
+
+    if (state.gbaFrame % 60 === 0) {
+      console.log('[RENDER] Frame', state.gbaFrame, 'type:', renderers.type, 'player:', player.tileX, player.tileY);
+    }
+
+    const ctx2d = canvas.getContext('2d');
+    if (!ctx2d) return;
+
+    // Build camera view
+    const camera = cameraRef.current;
+    if (!camera) return;
+
+    const camView = camera.getView(1); // +1 tile for sub-tile scrolling
+
+    // Build world camera view using shared utility
+    const view = buildWorldCameraView({
+      cameraX: camView.x,
+      cameraY: camView.y,
+      startTileX: camView.startTileX,
+      startTileY: camView.startTileY,
+      subTileOffsetX: camView.subTileOffsetX,
+      subTileOffsetY: camView.subTileOffsetY,
+      tilesWide: camView.tilesWide,
+      tilesHigh: camView.tilesHigh,
+      pixelWidth: camView.tilesWide * METATILE_SIZE,
+      pixelHeight: camView.tilesHigh * METATILE_SIZE,
+    });
+
+    // Get player elevation
+    const playerElevation = player.getElevation();
+
+    if (renderers.type === 'webgl' && renderers.getWebGLPipeline) {
+      // WebGL rendering path
+      const pipeline = renderers.getWebGLPipeline();
+      const spriteRenderer = renderers.spriteRenderer as WebGLSpriteRenderer;
+      const webglCanvas = renderers.webglCanvas;
+
+      if (!webglCanvas || !tilesetsUploadedRef.current) {
+        if (state.gbaFrame % 60 === 0) {
+          console.log('[RENDER] WebGL skip - webglCanvas:', !!webglCanvas, 'tilesetsUploaded:', tilesetsUploadedRef.current);
+        }
+        return;
+      }
+
+      if (state.gbaFrame % 60 === 0) {
+        console.log('[RENDER] WebGL rendering, view:', view.startTileX, view.startTileY, 'to', view.startTileX + view.tilesWide, view.startTileY + view.tilesHigh);
+      }
+
+      // Ensure display canvas is sized to viewport
+      if (canvas.width !== VIEWPORT_PIXEL_SIZE.width || canvas.height !== VIEWPORT_PIXEL_SIZE.height) {
+        canvas.width = VIEWPORT_PIXEL_SIZE.width;
+        canvas.height = VIEWPORT_PIXEL_SIZE.height;
+      }
+
+      // Render tiles using pipeline
+      pipeline.render(
+        null as any, // RenderContext not used by WebGL pipeline
+        view,
+        playerElevation,
+        { gameFrame: state.gbaFrame, needsFullRender: true, animationChanged: state.animationFrameChanged }
+      );
+
+      // Get NPCs and field effects
+      const npcs = objectEventManagerRef.current.getVisibleNPCs();
+      const fieldEffects = fieldSpritesLoadedRef.current
+        ? player.getGrassEffectManager().getEffectsForRendering()
+        : [];
+
+      // Build sprites using extracted hook
+      const spriteBuildResult = buildSprites({
+        player,
+        playerLoaded: playerLoadedRef.current,
+        playerHidden: playerHiddenRef.current,
+        snapshot,
+        tilesetRuntimes: tilesetRuntimesRef.current,
+        npcs,
+        fieldEffects,
+        spriteRenderer,
+        doorAnimations,
+        arrowOverlay,
+        doorSequencer,
+        doorSpritesUploaded: doorSpritesUploadedRef.current,
+        arrowSpriteUploaded: arrowSpriteUploadedRef.current,
+        nowTime: state.timestamp,
+        computeReflectionState: computeReflectionStateFromSnapshot,
+      });
+
+      // Track uploaded sprites
+      for (const atlasName of spriteBuildResult.newDoorSpritesUploaded) {
+        doorSpritesUploadedRef.current.add(atlasName);
+      }
+      if (spriteBuildResult.arrowSpriteWasUploaded) {
+        arrowSpriteUploadedRef.current = true;
+      }
+
+      // Get fade alpha
+      const fadeAlpha = fadeControllerRef.current.isActive()
+        ? fadeControllerRef.current.getAlpha(state.timestamp)
+        : 0;
+
+      // Composite frame
+      compositeWebGLFrame(
+        {
+          pipeline,
+          spriteRenderer,
+          fadeRenderer: renderers.fadeRenderer as any,
+          ctx2d,
+          webglCanvas,
+          view,
+          snapshot,
+          tilesetRuntimes: tilesetRuntimesRef.current,
+        },
+        {
+          lowPrioritySprites: spriteBuildResult.lowPrioritySprites,
+          allSprites: spriteBuildResult.allSprites,
+          priority0Sprites: spriteBuildResult.priority0Sprites,
+          doorSprites: spriteBuildResult.doorSprites,
+          arrowSprite: spriteBuildResult.arrowSprite,
+        },
+        { fadeAlpha }
+      );
+    } else {
+      // Canvas2D fallback - simplified rendering
+      ctx2d.fillStyle = '#000';
+      ctx2d.fillRect(0, 0, canvas.width, canvas.height);
+
+      ctx2d.fillStyle = '#fff';
+      ctx2d.font = '14px monospace';
+      ctx2d.textAlign = 'center';
+      ctx2d.fillText(
+        `Canvas2D mode - ${mapName}`,
+        canvas.width / 2,
+        canvas.height / 2 - 20
+      );
+      ctx2d.fillText(
+        `Frame: ${state.gbaFrame} | Player: (${player.tileX}, ${player.tileY})`,
+        canvas.width / 2,
+        canvas.height / 2 + 20
+      );
+      ctx2d.fillText(
+        'Canvas2D full implementation pending',
+        canvas.width / 2,
+        canvas.height / 2 + 60
+      );
+    }
+  }, [mapName, buildSprites, computeReflectionStateFromSnapshot, doorAnimations, arrowOverlay, doorSequencer]);
+
+  // Run game loop
+  useGameLoop(handleUpdate, handleRender, { running: !loading && !error });
+
+  if (error) {
+    return <div style={{ color: 'red' }}>Error: {error}</div>;
+  }
+
+  return (
+    <div>
+      {loading && <div>Loading {mapName}...</div>}
+      <div style={{
+        position: 'relative',
+        width: VIEWPORT_PIXEL_SIZE.width * zoom,
+        height: VIEWPORT_PIXEL_SIZE.height * zoom,
+      }}>
+        <canvas
+          ref={canvasRef}
+          width={VIEWPORT_PIXEL_SIZE.width}
+          height={VIEWPORT_PIXEL_SIZE.height}
+          style={{
+            border: '1px solid #ccc',
+            imageRendering: 'pixelated',
+            width: VIEWPORT_PIXEL_SIZE.width * zoom,
+            height: VIEWPORT_PIXEL_SIZE.height * zoom,
+          }}
+        />
+        <DialogBox
+          viewportWidth={VIEWPORT_PIXEL_SIZE.width * zoom}
+          viewportHeight={VIEWPORT_PIXEL_SIZE.height * zoom}
+        />
+      </div>
+
+      {rendererType && (
+        <div style={{ marginTop: 8, fontSize: 12, color: '#666' }}>
+          Renderer: {rendererType.toUpperCase()}
+        </div>
+      )}
+
+      <DebugPanel
+        options={debugOptions}
+        onChange={setDebugOptions}
+        state={debugState}
+      />
+    </div>
+  );
+});
+
+GameRenderer.displayName = 'GameRenderer';
diff --git a/src/components/debug/DebugPanel.tsx b/src/components/debug/DebugPanel.tsx
index b3d8b0a3..37147e32 100644
--- a/src/components/debug/DebugPanel.tsx
+++ b/src/components/debug/DebugPanel.tsx
@@ -19,6 +19,7 @@ import type {
   PriorityDebugInfo,
 } from './types';
 import type { NPCObject, ItemBallObject } from '../../types/objectEvents';
+import type { MapIndexEntry } from '../../types/maps';
 import { getSpritePriorityForElevation } from '../../utils/elevationPriority';
 
 const PANEL_WIDTH = 340;
@@ -41,6 +42,11 @@ interface DebugPanelProps {
   onCopyTileDebug?: () => void;
   /** WebGL-specific debug state (only shown when provided) */
   webglState?: WebGLDebugState | null;
+  /** Map selection props */
+  maps?: MapIndexEntry[];
+  selectedMapId?: string;
+  onMapChange?: (mapId: string) => void;
+  mapLoading?: boolean;
 }
 
 export const DebugPanel: React.FC<DebugPanelProps> = ({
@@ -55,9 +61,13 @@ export const DebugPanel: React.FC<DebugPanelProps> = ({
   compositeLayerCanvasRef,
   onCopyTileDebug,
   webglState,
+  maps,
+  selectedMapId,
+  onMapChange,
+  mapLoading,
 }) => {
   const [isOpen, setIsOpen] = useState(false);
-  const [activeTab, setActiveTab] = useState<'general' | 'objects' | 'tile' | 'webgl'>('general');
+  const [activeTab, setActiveTab] = useState<'map' | 'general' | 'objects' | 'tile' | 'webgl'>(maps ? 'map' : 'general');
 
   // Sync panel open state with debug enabled
   useEffect(() => {
@@ -176,6 +186,13 @@ export const DebugPanel: React.FC<DebugPanelProps> = ({
             backgroundColor: '#222',
           }}
         >
+          {maps && (
+            <TabButton
+              label="Map"
+              active={activeTab === 'map'}
+              onClick={() => setActiveTab('map')}
+            />
+          )}
           <TabButton
             label="General"
             active={activeTab === 'general'}
@@ -208,6 +225,15 @@ export const DebugPanel: React.FC<DebugPanelProps> = ({
             padding: '12px 16px',
           }}
         >
+          {activeTab === 'map' && maps && (
+            <MapTab
+              maps={maps}
+              selectedMapId={selectedMapId}
+              onMapChange={onMapChange}
+              loading={mapLoading}
+              webglState={webglState}
+            />
+          )}
           {activeTab === 'general' && (
             <GeneralTab options={options} updateOption={updateOption} state={state} />
           )}
@@ -257,6 +283,74 @@ const TabButton: React.FC<{
   </button>
 );
 
+// Map selection tab
+const MapTab: React.FC<{
+  maps: MapIndexEntry[];
+  selectedMapId?: string;
+  onMapChange?: (mapId: string) => void;
+  loading?: boolean;
+  webglState?: WebGLDebugState | null;
+}> = ({ maps, selectedMapId, onMapChange, loading, webglState }) => {
+  const selectedMap = maps.find(m => m.id === selectedMapId);
+  const renderStats = webglState?.renderStats;
+
+  return (
+    <div style={{ display: 'flex', flexDirection: 'column', gap: 12 }}>
+      <Section title="Choose Map">
+        <select
+          value={selectedMapId || ''}
+          onChange={(e) => {
+            onMapChange?.(e.target.value);
+            e.currentTarget.blur();
+          }}
+          style={{
+            width: '100%',
+            padding: '8px',
+            backgroundColor: '#1a1a2e',
+            color: '#fff',
+            border: '1px solid #333',
+            borderRadius: 4,
+            fontSize: '12px',
+            fontFamily: 'monospace',
+          }}
+        >
+          {maps.map((map) => (
+            <option key={map.id} value={map.id}>
+              {map.name} ({map.width}×{map.height})
+            </option>
+          ))}
+        </select>
+        {loading && (
+          <div style={{ marginTop: 8, color: '#4a9eff', fontSize: '11px' }}>
+            Loading map data…
+          </div>
+        )}
+      </Section>
+
+      {selectedMap && (
+        <Section title="Map Info">
+          <div style={{ display: 'flex', flexDirection: 'column', gap: 4 }}>
+            <InfoRow label="Name" value={selectedMap.name} />
+            <InfoRow label="Size" value={`${selectedMap.width}×${selectedMap.height} metatiles`} />
+            <InfoRow
+              label="Tilesets"
+              value={`${selectedMap.primaryTilesetId.replace('gTileset_', '')} / ${selectedMap.secondaryTilesetId.replace('gTileset_', '')}`}
+            />
+            {renderStats && (
+              <>
+                <InfoRow label="World" value={`${renderStats.worldWidthPx}×${renderStats.worldHeightPx}px`} />
+                {renderStats.stitchedMapCount > 1 && (
+                  <InfoRow label="Stitched" value={`${renderStats.stitchedMapCount} maps`} highlight />
+                )}
+              </>
+            )}
+          </div>
+        </Section>
+      )}
+    </div>
+  );
+};
+
 // Collision legend component
 const CollisionLegend: React.FC = () => (
   <div style={{ marginTop: 8, marginBottom: 8, padding: 8, backgroundColor: '#2a2a2a', borderRadius: 4 }}>
@@ -1100,6 +1194,9 @@ const WebGLTab: React.FC<{ webglState: WebGLDebugState }> = ({ webglState }) =>
           </div>
           <div style={{ marginTop: 4 }}>
             <InfoRow label="World" value={`${renderStats.worldWidthPx}×${renderStats.worldHeightPx}px`} />
+            {renderStats.stitchedMapCount > 1 && (
+              <InfoRow label="Stitched" value={`${renderStats.stitchedMapCount} maps`} highlight />
+            )}
           </div>
         </Section>
       )}
@@ -1324,13 +1421,14 @@ const Checkbox: React.FC<{
   </label>
 );
 
-const InfoRow: React.FC<{ label: string; value: React.ReactNode }> = ({
+const InfoRow: React.FC<{ label: string; value: React.ReactNode; highlight?: boolean }> = ({
   label,
   value,
+  highlight,
 }) => (
   <div style={{ display: 'flex', justifyContent: 'space-between', padding: '2px 0' }}>
     <span style={{ color: '#888' }}>{label}:</span>
-    <span style={{ color: '#fff' }}>{value}</span>
+    <span style={{ color: highlight ? '#4fc3f7' : '#fff' }}>{value}</span>
   </div>
 );
 
diff --git a/src/components/debug/types.ts b/src/components/debug/types.ts
index 19ebfd8a..c8e55827 100644
--- a/src/components/debug/types.ts
+++ b/src/components/debug/types.ts
@@ -193,6 +193,7 @@ export interface RenderStatsDebugInfo {
   cameraY: number;
   worldWidthPx: number;
   worldHeightPx: number;
+  stitchedMapCount: number;
 }
 
 /**
diff --git a/src/game/PlayerController.ts b/src/game/PlayerController.ts
index 4af54da9..a0fa700a 100644
--- a/src/game/PlayerController.ts
+++ b/src/game/PlayerController.ts
@@ -287,7 +287,8 @@ class SurfingState implements PlayerState {
 
   update(controller: PlayerController, delta: number): boolean {
     // Update surfing controller (handles bob animation)
-    controller.updateSurfing();
+    // delta is in milliseconds for frame-rate independent bobbing
+    controller.updateSurfing(delta);
     return controller.processMovement(delta, this.SPEED);
   }
 
@@ -333,9 +334,10 @@ class SurfJumpingState implements PlayerState {
     controller.spriteYOffset = 0;
   }
 
-  update(controller: PlayerController, _delta: number): boolean {
+  update(controller: PlayerController, delta: number): boolean {
     const surfController = controller.getSurfingController();
-    const result = surfController.update();
+    // Pass delta for frame-rate independent bobbing
+    const result = surfController.update(delta);
 
     // Apply jump Y offset
     controller.spriteYOffset = result.jumpYOffset;
@@ -587,6 +589,38 @@ export class PlayerController {
     this.dir = dir;
   }
 
+  /**
+   * Reset all map-specific state when warping to a new map.
+   * Called at the start of executeWarp() before setting new position.
+   *
+   * Clears:
+   * - Player movement state (resets to walking)
+   * - Key input state (prevents held keys from carrying over)
+   * - Previous tile tracking (prevents stale data affecting new map)
+   * - Field effects (sand footprints, grass, water ripples)
+   * - Surfing controller state (if mid-animation)
+   */
+  public resetForWarp(): void {
+    // 1. Reset to walking state (GBA always walks through doors)
+    if (!(this.currentState instanceof NormalState)) {
+      this.changeState(new NormalState());
+    }
+
+    // 2. Clear key input state - prevents held keys from carrying over
+    this.keysPressed = {};
+
+    // 3. Clear previous tile tracking - prevents stale data affecting new map
+    this.prevTileX = -1;
+    this.prevTileY = -1;
+    this.prevTileBehavior = undefined;
+
+    // 4. Clear field effects (sand footprints, grass, water ripples)
+    this.grassEffectManager.clear();
+
+    // 5. Reset surfing controller if mid-animation
+    this.surfingController.reset();
+  }
+
   /**
    * Get the player's elevation for RENDERING priority
    *
@@ -1275,11 +1309,14 @@ export class PlayerController {
     // - Only the Y-position bobs up/down with the surf blob
     // - Walk frames (1, 3, 5) are ONLY used during mount/dismount jump sequences
 
-    // Always use idle frame - movement is shown via bob offset, not frame animation
-    if (this.dir === 'down') srcIndex = 0;
-    else if (this.dir === 'up') srcIndex = 2;
-    else if (this.dir === 'left') srcIndex = 4;
-    else if (this.dir === 'right') { srcIndex = 4; flip = true; }
+    // Use walk frames during mount/dismount, idle frames during normal surfing
+    const isJumping = this.surfingController.isJumping();
+    const frameOffset = isJumping ? 1 : 0; // +1 for walk frame
+
+    if (this.dir === 'down') srcIndex = 0 + frameOffset;
+    else if (this.dir === 'up') srcIndex = 2 + frameOffset;
+    else if (this.dir === 'left') srcIndex = 4 + frameOffset;
+    else if (this.dir === 'right') { srcIndex = 4 + frameOffset; flip = true; }
 
     const srcX = srcIndex * SURF_FRAME_WIDTH;
     const srcY = 0;
@@ -1775,9 +1812,9 @@ export class PlayerController {
    * Update surfing state (bob animation, etc.)
    * Called by SurfingState.update()
    */
-  public updateSurfing(): void {
-    // Update surfing controller for bob animation
-    this.surfingController.update();
+  public updateSurfing(deltaMs?: number): void {
+    // Update surfing controller for bob animation (pass delta for frame-rate independent timing)
+    this.surfingController.update(deltaMs);
 
     // Update blob direction based on player facing
     this.surfingController.updateBlobDirection(this.dir);
@@ -1932,7 +1969,8 @@ export class PlayerController {
    * Returns 'surfing', 'running', or 'walking'.
    */
   public getCurrentSpriteKey(): string {
-    if (this.isSurfing()) return 'surfing';
+    // Check for surfing OR mount/dismount jump (which also uses surfing sprite)
+    if (this.isSurfing() || this.surfingController.isJumping()) return 'surfing';
     if (this.isRunning()) return 'running';
     return 'walking';
   }
diff --git a/src/game/WarpExecutor.ts b/src/game/WarpExecutor.ts
index 461aa20e..3d2a6e4a 100644
--- a/src/game/WarpExecutor.ts
+++ b/src/game/WarpExecutor.ts
@@ -333,6 +333,10 @@ export function executeWarp(
     onClearDoorAnimations,
   } = deps;
 
+  // Reset all map-specific player state before warp
+  // This clears: movement state, key input, previous tile tracking, field effects, surfing state
+  player.resetForWarp();
+
   const destWarpId = trigger.warpEvent.destWarpId;
   const now = getCurrentTime();
 
diff --git a/src/game/surfing/SurfBlobRenderer.ts b/src/game/surfing/SurfBlobRenderer.ts
index 449fcf7a..8305f6a2 100644
--- a/src/game/surfing/SurfBlobRenderer.ts
+++ b/src/game/surfing/SurfBlobRenderer.ts
@@ -16,11 +16,18 @@ export class SurfBlobRenderer {
 
   // GBA-accurate discrete stepped bobbing (not smooth sine wave)
   // Reference: pokeemerald/src/field_effect_helpers.c:1107-1135
-  // - Updates every 4 frames (timer & 0x3 == 0)
+  // - Updates every 4 frames at 60fps = every 66.67ms
   // - Velocity ±1 pixel per update
-  // - Reverses direction every 16 frames (timer & 15 == 0)
+  // - Reverses direction every 16 frames at 60fps = every 266.67ms
   // - Range: -4 to +4 pixels
-  private bobTimer: number = 0;
+  //
+  // We use time-based timing for frame-rate independence
+  private readonly FRAME_DURATION_MS = 1000 / 60; // GBA frame duration ~16.67ms
+  private readonly BOB_UPDATE_INTERVAL = 4 * this.FRAME_DURATION_MS; // ~66.67ms
+  private readonly BOB_REVERSE_INTERVAL = 16 * this.FRAME_DURATION_MS; // ~266.67ms
+
+  private bobAccumulator: number = 0; // Time accumulator for bob updates
+  private reverseAccumulator: number = 0; // Time accumulator for direction reversal
   private bobVelocity: number = -1;  // Start at -1 (go down first), matches C code: sprite->sVelocity = -1
   private bobOffset: number = 0;   // Current Y offset (integer, -4 to +4)
 
@@ -35,6 +42,14 @@ export class SurfBlobRenderer {
     this.loadSprite();
   }
 
+  /**
+   * Wait for sprite to finish loading.
+   * Call this before attempting to upload to WebGL.
+   */
+  public waitForLoad(): Promise<void> {
+    return this.loadSprite();
+  }
+
   private loadSprite(): Promise<void> {
     if (this.loadPromise) {
       return this.loadPromise;
@@ -86,29 +101,48 @@ export class SurfBlobRenderer {
    * Update bobbing animation using GBA-accurate discrete stepping.
    *
    * Reference: pokeemerald/src/field_effect_helpers.c:1107-1135
-   * - Updates bob position every 4 frames (timer & 0x3 == 0)
-   * - Reverses direction every 16 frames (timer & 15 == 0)
+   * - ONLY updates when bobState != BOB_NONE
+   * - Updates bob position every 4 frames (timer & 0x3 == 0) = every ~66.67ms
+   * - Reverses direction every 16 frames (timer & 15 == 0) = every ~266.67ms
    * - This creates a stepped sawtooth pattern, not smooth sine
+   *
+   * Uses time-based accumulation for frame-rate independent timing.
+   *
+   * @param deltaMs Time since last update in milliseconds (optional, defaults to 16.67ms)
    */
-  public update(): void {
-    this.bobTimer++;
+  public update(deltaMs: number = this.FRAME_DURATION_MS): void {
+    // GBA: if (bobState != BOB_NONE) - skip entire update when BOB_NONE
+    if (this.bobState === 'BOB_NONE') {
+      return;
+    }
+
+    // Accumulate time for bob updates
+    this.bobAccumulator += deltaMs;
+    this.reverseAccumulator += deltaMs;
 
-    // Update bob position every 4 frames (timer & 0x3 == 0)
-    if ((this.bobTimer & 0x3) === 0) {
+    // Update bob position every ~66.67ms (4 frames at 60fps)
+    while (this.bobAccumulator >= this.BOB_UPDATE_INTERVAL) {
+      this.bobAccumulator -= this.BOB_UPDATE_INTERVAL;
       this.bobOffset += this.bobVelocity;
     }
 
-    // Reverse direction every 16 frames (timer & 15 == 0)
-    if ((this.bobTimer & 15) === 0) {
+    // Reverse direction every ~266.67ms (16 frames at 60fps)
+    while (this.reverseAccumulator >= this.BOB_REVERSE_INTERVAL) {
+      this.reverseAccumulator -= this.BOB_REVERSE_INTERVAL;
       this.bobVelocity = -this.bobVelocity;
     }
   }
 
   /**
    * Get current bob offset (vertical displacement) for the BLOB.
+   * Returns 0 when BOB_NONE (no bobbing during mount).
    * Returns integer value (-4 to +4) for GBA-accurate discrete stepping.
    */
   public getBobOffset(): number {
+    // When BOB_NONE, blob doesn't visually bob
+    if (this.bobState === 'BOB_NONE') {
+      return 0;
+    }
     return this.bobOffset;
   }
 
@@ -150,7 +184,8 @@ export class SurfBlobRenderer {
    * Reset bobbing state (for new surf session)
    */
   public resetBob(): void {
-    this.bobTimer = 0;
+    this.bobAccumulator = 0;
+    this.reverseAccumulator = 0;
     this.bobVelocity = -1;  // Start at -1 (go down first), matches C code
     this.bobOffset = 0;
   }
@@ -243,4 +278,12 @@ export class SurfBlobRenderer {
   public getDimensions(): { width: number; height: number } {
     return { width: this.FRAME_WIDTH, height: this.FRAME_HEIGHT };
   }
+
+  /**
+   * Get the sprite canvas for WebGL upload
+   * Returns null if sprite not yet loaded
+   */
+  public getSpriteCanvas(): HTMLCanvasElement | null {
+    return this.sprite;
+  }
 }
diff --git a/src/game/surfing/SurfingController.ts b/src/game/surfing/SurfingController.ts
index f0542d29..5db1ea6f 100644
--- a/src/game/surfing/SurfingController.ts
+++ b/src/game/surfing/SurfingController.ts
@@ -170,9 +170,10 @@ export class SurfingController {
   /**
    * Update surfing animation state machine
    * Call this every frame
+   * @param deltaMs Time since last update in milliseconds (for frame-rate independent bobbing)
    * @returns Object with state change info and jump offsets
    */
-  public update(): {
+  public update(deltaMs?: number): {
     stateChanged: boolean;
     jumpComplete: boolean;
     jumpYOffset: number;
@@ -189,7 +190,7 @@ export class SurfingController {
 
     // Always update blob bobbing during surfing or any jump animation
     if (this.state.isSurfing || this.state.animationPhase === 'JUMPING_ON' || this.state.animationPhase === 'JUMPING_OFF') {
-      this.blobRenderer.update();
+      this.blobRenderer.update(deltaMs);
     }
 
     switch (this.state.animationPhase) {
diff --git a/src/hooks/useGameLoop.ts b/src/hooks/useGameLoop.ts
new file mode 100644
index 00000000..454a1c90
--- /dev/null
+++ b/src/hooks/useGameLoop.ts
@@ -0,0 +1,226 @@
+/**
+ * useGameLoop - Unified game loop with GBA-accurate frame timing
+ *
+ * Provides:
+ * - Fixed timestep at 59.7275 Hz (true GBA vblank timing)
+ * - Animation frame counter for tileset animations
+ * - Shimmer animation updates
+ * - Delta time tracking
+ *
+ * Used by both WebGL and Canvas2D renderers.
+ */
+
+import { useRef, useEffect, useCallback } from 'react';
+import { getGlobalShimmer } from '../field/ReflectionRenderer';
+
+// GBA vblank timing: 59.7275 Hz (16.7427ms per frame)
+const GBA_FRAME_MS = 1000 / 59.7275;
+
+// Animation frame period: every 10 GBA frames (~167ms)
+const ANIMATION_FRAME_TICKS = 10;
+
+/**
+ * Frame state passed to callbacks
+ */
+export interface GameFrameState {
+  /** Current GBA frame counter (increments at 59.7275 Hz) */
+  gbaFrame: number;
+  /** Animation frame for tileset animations (gbaFrame / 10) */
+  animationFrame: number;
+  /** Time since last RAF call in ms */
+  deltaTime: number;
+  /** Current timestamp from performance.now() */
+  timestamp: number;
+  /** Whether animation frame changed this tick */
+  animationFrameChanged: boolean;
+}
+
+/**
+ * Update function called each fixed timestep
+ */
+export type GameUpdateFn = (deltaMs: number, timestamp: number) => void;
+
+/**
+ * Render function called each animation frame
+ */
+export type GameRenderFn = (state: GameFrameState) => void;
+
+export interface UseGameLoopOptions {
+  /** Whether the loop should be running */
+  running?: boolean;
+  /** Optional custom frame rate (default: GBA 59.7275 Hz) */
+  frameRateHz?: number;
+}
+
+export interface UseGameLoopReturn {
+  /** Current GBA frame counter */
+  gbaFrame: number;
+  /** Current animation frame */
+  animationFrame: number;
+  /** Start the game loop */
+  start: () => void;
+  /** Stop the game loop */
+  stop: () => void;
+  /** Whether the loop is currently running */
+  isRunning: boolean;
+}
+
+/**
+ * Hook for running a GBA-accurate game loop.
+ *
+ * @param onUpdate - Called each fixed timestep (game logic)
+ * @param onRender - Called each RAF (rendering)
+ * @param options - Loop configuration
+ */
+export function useGameLoop(
+  onUpdate: GameUpdateFn,
+  onRender: GameRenderFn,
+  options: UseGameLoopOptions = {}
+): UseGameLoopReturn {
+  const { running: initialRunning = true, frameRateHz = 59.7275 } = options;
+
+  const frameMs = 1000 / frameRateHz;
+
+  // Refs for loop state
+  const runningRef = useRef(initialRunning);
+  const rafIdRef = useRef<number | null>(null);
+  const lastTimeRef = useRef(performance.now());
+  const accumulatorRef = useRef(0);
+  const gbaFrameRef = useRef(0);
+  const lastAnimationFrameRef = useRef(0);
+
+  // Refs for callbacks (avoid stale closures)
+  const onUpdateRef = useRef(onUpdate);
+  const onRenderRef = useRef(onRender);
+  onUpdateRef.current = onUpdate;
+  onRenderRef.current = onRender;
+
+  const tick = useCallback((currentTime: number) => {
+    if (!runningRef.current) return;
+
+    const deltaTime = currentTime - lastTimeRef.current;
+    lastTimeRef.current = currentTime;
+    accumulatorRef.current += deltaTime;
+
+    // Update shimmer animation
+    getGlobalShimmer().update(currentTime);
+
+    // Fixed timestep loop
+    while (accumulatorRef.current >= frameMs) {
+      accumulatorRef.current -= frameMs;
+      gbaFrameRef.current++;
+
+      // Call update function each fixed step
+      onUpdateRef.current(frameMs, currentTime);
+    }
+
+    // Calculate animation frame
+    const animationFrame = Math.floor(gbaFrameRef.current / ANIMATION_FRAME_TICKS);
+    const animationFrameChanged = animationFrame !== lastAnimationFrameRef.current;
+    lastAnimationFrameRef.current = animationFrame;
+
+    // Build frame state for render
+    const frameState: GameFrameState = {
+      gbaFrame: gbaFrameRef.current,
+      animationFrame,
+      deltaTime,
+      timestamp: currentTime,
+      animationFrameChanged,
+    };
+
+    // Call render function
+    onRenderRef.current(frameState);
+
+    // Schedule next frame
+    rafIdRef.current = requestAnimationFrame(tick);
+  }, [frameMs]);
+
+  const start = useCallback(() => {
+    if (runningRef.current) return;
+    runningRef.current = true;
+    lastTimeRef.current = performance.now();
+    accumulatorRef.current = frameMs; // Ensure first frame runs update
+    rafIdRef.current = requestAnimationFrame(tick);
+  }, [tick, frameMs]);
+
+  const stop = useCallback(() => {
+    runningRef.current = false;
+    if (rafIdRef.current !== null) {
+      cancelAnimationFrame(rafIdRef.current);
+      rafIdRef.current = null;
+    }
+  }, []);
+
+  // Auto-start/stop based on running option
+  useEffect(() => {
+    if (initialRunning) {
+      start();
+    }
+    return () => {
+      stop();
+    };
+  }, [initialRunning, start, stop]);
+
+  return {
+    gbaFrame: gbaFrameRef.current,
+    animationFrame: lastAnimationFrameRef.current,
+    start,
+    stop,
+    isRunning: runningRef.current,
+  };
+}
+
+/**
+ * Simpler hook that just provides GBA frame timing without callbacks.
+ * Useful for components that need frame state but manage their own rendering.
+ */
+export function useGBAFrameCounter(): {
+  gbaFrame: number;
+  animationFrame: number;
+  timestamp: number;
+} {
+  const gbaFrameRef = useRef(0);
+  const animationFrameRef = useRef(0);
+  const timestampRef = useRef(performance.now());
+  const lastTimeRef = useRef(performance.now());
+  const accumulatorRef = useRef(0);
+  const rafIdRef = useRef<number | null>(null);
+
+  useEffect(() => {
+    const tick = (currentTime: number) => {
+      const deltaTime = currentTime - lastTimeRef.current;
+      lastTimeRef.current = currentTime;
+      accumulatorRef.current += deltaTime;
+      timestampRef.current = currentTime;
+
+      // Update shimmer
+      getGlobalShimmer().update(currentTime);
+
+      // Fixed timestep
+      while (accumulatorRef.current >= GBA_FRAME_MS) {
+        accumulatorRef.current -= GBA_FRAME_MS;
+        gbaFrameRef.current++;
+      }
+
+      animationFrameRef.current = Math.floor(gbaFrameRef.current / ANIMATION_FRAME_TICKS);
+      rafIdRef.current = requestAnimationFrame(tick);
+    };
+
+    rafIdRef.current = requestAnimationFrame(tick);
+
+    return () => {
+      if (rafIdRef.current !== null) {
+        cancelAnimationFrame(rafIdRef.current);
+      }
+    };
+  }, []);
+
+  return {
+    gbaFrame: gbaFrameRef.current,
+    animationFrame: animationFrameRef.current,
+    timestamp: timestampRef.current,
+  };
+}
+
+// Re-export constants for use elsewhere
+export { GBA_FRAME_MS, ANIMATION_FRAME_TICKS };
diff --git a/src/hooks/useWebGLSpriteBuilder.ts b/src/hooks/useWebGLSpriteBuilder.ts
index 4a114252..abcbc9a5 100644
--- a/src/hooks/useWebGLSpriteBuilder.ts
+++ b/src/hooks/useWebGLSpriteBuilder.ts
@@ -92,6 +92,8 @@ export interface SpriteBuildResult {
   doorSprites: SpriteInstance[];
   /** Arrow overlay sprite (if visible) */
   arrowSprite: SpriteInstance | null;
+  /** Surf blob sprite (rendered behind player when surfing) */
+  surfBlobSprite: SpriteInstance | null;
   /** Player world Y for layer calculations */
   playerWorldY: number;
   /** Whether any new door sprites were uploaded */
@@ -133,6 +135,7 @@ export function useWebGLSpriteBuilder(): UseWebGLSpriteBuilderReturn {
     const priority0Sprites: SpriteInstance[] = [];
     const doorSprites: SpriteInstance[] = [];
     let arrowSprite: SpriteInstance | null = null;
+    let surfBlobSprite: SpriteInstance | null = null;
     const newDoorSpritesUploaded: string[] = [];
     let arrowSpriteWasUploaded = false;
 
@@ -221,6 +224,82 @@ export function useWebGLSpriteBuilder(): UseWebGLSpriteBuilderReturn {
       }
     }
 
+    // === Build surf blob sprite (if surfing or mounting/dismounting) ===
+    if (playerLoaded && !playerHidden && spriteRenderer.hasSpriteSheet('surf-blob')) {
+      const surfCtrl = player.getSurfingController();
+      const shouldRenderBlob = player.isSurfing() || surfCtrl.isJumping();
+
+      if (shouldRenderBlob) {
+        const blobRenderer = surfCtrl.getBlobRenderer();
+        const bobOffset = blobRenderer.getBobOffset();
+
+        // Determine blob position based on current animation phase
+        let blobWorldX: number;
+        let blobWorldY: number;
+
+        if (surfCtrl.isJumpingOn()) {
+          // MOUNTING: Blob is at target water tile (destination)
+          const targetPos = surfCtrl.getTargetPosition();
+          if (targetPos) {
+            blobWorldX = targetPos.tileX * METATILE_SIZE - 8;
+            blobWorldY = targetPos.tileY * METATILE_SIZE - 16 + bobOffset + 8;
+          } else {
+            blobWorldX = player.x - 8;
+            blobWorldY = player.y + bobOffset + 8;
+          }
+        } else if (surfCtrl.isJumpingOff()) {
+          // DISMOUNTING: Blob stays at fixed water tile position
+          const fixedPos = surfCtrl.getBlobFixedPosition();
+          if (fixedPos) {
+            blobWorldX = fixedPos.tileX * METATILE_SIZE - 8;
+            blobWorldY = fixedPos.tileY * METATILE_SIZE - 16 + bobOffset + 8;
+          } else {
+            blobWorldX = player.x - 8;
+            blobWorldY = player.y + bobOffset + 8;
+          }
+        } else {
+          // Normal surfing: Blob follows player
+          blobWorldX = player.x - 8;
+          blobWorldY = player.y + bobOffset + 8;
+        }
+
+        // Get frame based on direction
+        // Frame 0: down/up, Frame 1: left, Frame 1 (flipped): right
+        const dir = player.dir;
+        let atlasX = 0;
+        let flipX = false;
+        if (dir === 'left') {
+          atlasX = 32;
+        } else if (dir === 'right') {
+          atlasX = 32;
+          flipX = true;
+        }
+
+        // Blob renders behind player, so use slightly lower sortKey
+        const blobSortKey = calculateSortKey(blobWorldY, 0) - 1;
+
+        surfBlobSprite = {
+          worldX: blobWorldX,
+          worldY: blobWorldY,
+          width: 32,
+          height: 32,
+          atlasName: 'surf-blob',
+          atlasX,
+          atlasY: 0,
+          atlasWidth: 32,
+          atlasHeight: 32,
+          flipX,
+          flipY: false,
+          alpha: 1.0,
+          tintR: 1.0,
+          tintG: 1.0,
+          tintB: 1.0,
+          sortKey: blobSortKey,
+          isReflection: false,
+        };
+      }
+    }
+
     // === Use SpriteBatcher for unified sprite sorting ===
     const spriteBatches = buildSpriteBatches(player, npcs, fieldEffects, {
       includePlayerShadow: player.showShadow,
@@ -291,6 +370,10 @@ export function useWebGLSpriteBuilder(): UseWebGLSpriteBuilderReturn {
 
         const clipToHalf = info.player.isOnLongGrass();
         const playerSprite = createSpriteFromFrameInfo(frameInfo, atlasName, info.sortKey, clipToHalf);
+
+        // Note: Bob offset for surfing is already applied in SurfingState.getFrameInfo()
+        // (see PlayerController.ts line 304-305), so we don't apply it here
+
         allSprites.push(playerSprite);
 
         // Add player reflection
@@ -347,6 +430,7 @@ export function useWebGLSpriteBuilder(): UseWebGLSpriteBuilderReturn {
       priority0Sprites,
       doorSprites,
       arrowSprite,
+      surfBlobSprite,
       playerWorldY,
       newDoorSpritesUploaded,
       arrowSpriteWasUploaded,
diff --git a/src/main.tsx b/src/main.tsx
index 91088241..19570f3c 100644
--- a/src/main.tsx
+++ b/src/main.tsx
@@ -1,9 +1,12 @@
 import { StrictMode, useState, useEffect } from 'react'
 import { createRoot } from 'react-dom/client'
 import './index.css'
-import App from './App.tsx'
+import { GamePage } from './pages/GamePage.tsx'
+import { LegacyCanvasPage } from './pages/LegacyCanvasPage.tsx'
 import { WebGLTestPage } from './pages/WebGLTestPage.tsx'
-import { WebGLMapPage } from './pages/WebGLMapPage.tsx'
+import { SurfingSpriteDebugPage } from './pages/SurfingSpriteDebugPage.tsx'
+import { GameRenderer } from './components/GameRenderer.tsx'
+import { DialogProvider } from './components/dialog'
 
 /**
  * Simple hash-based router for development/testing pages
@@ -21,11 +24,23 @@ function Router() {
   if (route === '#/webgl-test') {
     return <WebGLTestPage />;
   }
-  if (route === '#/webgl-map') {
-    return <WebGLMapPage />;
+  if (route === '#/legacy') {
+    return <LegacyCanvasPage />;
+  }
+  if (route === '#/surfing-sprite') {
+    return <SurfingSpriteDebugPage />;
+  }
+  // New unified GameRenderer (work in progress)
+  if (route === '#/play' || route.startsWith('#/play?')) {
+    return (
+      <DialogProvider zoom={1}>
+        <GameRenderer mapId="MAP_LITTLEROOT_TOWN" mapName="Littleroot Town" zoom={2} />
+      </DialogProvider>
+    );
   }
 
-  return <App />;
+  // WebGL game page is the default
+  return <GamePage />;
 }
 
 createRoot(document.getElementById('root')!).render(
diff --git a/src/pages/WebGLMapPage.css b/src/pages/GamePage.css
similarity index 95%
rename from src/pages/WebGLMapPage.css
rename to src/pages/GamePage.css
index eb64de11..06f553fe 100644
--- a/src/pages/WebGLMapPage.css
+++ b/src/pages/GamePage.css
@@ -1,4 +1,4 @@
-.webgl-map-page {
+.game-page {
   padding: 1.5rem;
   color: #e6e6e6;
   background: #0f1115;
@@ -6,7 +6,7 @@
   font-family: 'Inter', system-ui, -apple-system, sans-serif;
 }
 
-.webgl-map-page h1 {
+.game-page h1 {
   margin: 0 0 0.25rem 0;
 }
 
@@ -64,7 +64,7 @@
   padding: 0.5rem;
 }
 
-.webgl-map-canvas {
+.game-canvas {
   display: block;
   image-rendering: pixelated;
   background: #000;
diff --git a/src/pages/WebGLMapPage.tsx b/src/pages/GamePage.tsx
similarity index 93%
rename from src/pages/WebGLMapPage.tsx
rename to src/pages/GamePage.tsx
index e5b81507..ca62031b 100644
--- a/src/pages/WebGLMapPage.tsx
+++ b/src/pages/GamePage.tsx
@@ -1,12 +1,11 @@
 /**
- * WebGL Map Viewer
+ * Game Page (WebGL Renderer)
  *
- * Replacement for the old gameplay-heavy MapRenderer route.
- * This page mirrors the WebGL test harness but renders any map
- * from the map index using only the WebGL tile renderer (no NPCs,
- * scripts, camera, or gameplay systems).
+ * Main game page using WebGL rendering for hardware-accelerated
+ * tile and sprite rendering. Supports dynamic map loading, NPCs,
+ * warps, and all gameplay systems.
  *
- * Access via /#/webgl-map
+ * This is the default page at /
  */
 
 import { useEffect, useMemo, useRef, useState, useCallback } from 'react';
@@ -95,7 +94,9 @@ import {
   startDoorWarpSequence,
   type DoorWarpContext,
 } from '../game/DoorActionDispatcher';
-import './WebGLMapPage.css';
+import { DialogProvider, DialogBox, useDialog } from '../components/dialog';
+import { useActionInput } from '../hooks/useActionInput';
+import './GamePage.css';
 
 const GBA_FRAME_MS = 1000 / 59.7275; // Match real GBA vblank timing (~59.73 Hz)
 
@@ -117,7 +118,28 @@ const VIEWPORT_TILES_WIDE = DEFAULT_VIEWPORT_CONFIG.tilesWide;
 const VIEWPORT_TILES_HIGH = DEFAULT_VIEWPORT_CONFIG.tilesHigh;
 const VIEWPORT_PIXEL_SIZE = getViewportPixelSize();
 
-export function WebGLMapPage() {
+/**
+ * GamePage wrapper - provides DialogProvider context
+ */
+export function GamePage() {
+  const [zoom, setZoom] = useState(2); // Default to 2x zoom for better visibility
+
+  return (
+    <DialogProvider zoom={zoom}>
+      <GamePageContent zoom={zoom} onZoomChange={setZoom} />
+    </DialogProvider>
+  );
+}
+
+interface GamePageContentProps {
+  zoom: number;
+  onZoomChange: (zoom: number) => void;
+}
+
+/**
+ * GamePageContent - main game rendering and logic
+ */
+function GamePageContent({ zoom, onZoomChange }: GamePageContentProps) {
   // Canvas refs - we use two canvases: hidden WebGL and visible 2D
   const displayCanvasRef = useRef<HTMLCanvasElement>(null);
   const webglCanvasRef = useRef<HTMLCanvasElement | null>(null);
@@ -175,6 +197,18 @@ export function WebGLMapPage() {
   const visibleNPCsRef = useRef<NPCObject[]>([]);
   const visibleItemsRef = useRef<ItemBallObject[]>([]);
 
+  // Dialog system
+  const { showYesNo, showMessage, isOpen: dialogIsOpen } = useDialog();
+
+  // Action input hook (handles X key for surf/item pickup dialogs)
+  useActionInput({
+    playerControllerRef: playerRef,
+    objectEventManagerRef,
+    dialogIsOpen,
+    showMessage,
+    showYesNo,
+  });
+
   const renderableMaps = useMemo(
     () =>
       mapIndexData
@@ -204,7 +238,6 @@ export function WebGLMapPage() {
   });
   const [loading, setLoading] = useState(false);
   const [cameraDisplay, setCameraDisplay] = useState<{ x: number; y: number }>({ x: 0, y: 0 });
-  const [zoom, setZoom] = useState(2); // Default to 2x zoom for better visibility
   const [mapDebugInfo, setMapDebugInfo] = useState<{
     currentMap: string | null;
     anchorMap: string;
@@ -254,11 +287,12 @@ export function WebGLMapPage() {
       cameraY: Math.round(cameraDisplay.y),
       worldWidthPx: worldSize.width,
       worldHeightPx: worldSize.height,
+      stitchedMapCount,
     },
     shimmer: getGlobalShimmer().getDebugInfo(),
     reflectionTileGrid: reflectionTileGridDebug,
     priority: priorityDebugInfo,
-  }), [mapDebugInfo, warpDebugInfo, stats, cameraDisplay, worldSize, reflectionTileGridDebug, priorityDebugInfo]);
+  }), [mapDebugInfo, warpDebugInfo, stats, cameraDisplay, worldSize, stitchedMapCount, reflectionTileGridDebug, priorityDebugInfo]);
 
   // Debug state for the panel - reads from refs updated during render loop
   const debugState = useMemo<DebugState>(() => {
@@ -547,9 +581,9 @@ export function WebGLMapPage() {
     webglCanvasRef.current = webglCanvas;
 
     if (!isWebGL2Supported(webglCanvas)) {
-      // WebGL2 not supported - redirect to Canvas2D mode
-      console.warn('WebGL2 not supported, redirecting to Canvas2D mode');
-      window.location.hash = '';
+      // WebGL2 not supported - redirect to legacy Canvas2D mode
+      console.warn('WebGL2 not supported, redirecting to legacy Canvas2D mode');
+      window.location.hash = '#/legacy';
       return;
     }
 
@@ -568,9 +602,9 @@ export function WebGLMapPage() {
       fadeRenderer.initialize();
       fadeRendererRef.current = fadeRenderer;
     } catch (e) {
-      // WebGL pipeline creation failed - redirect to Canvas2D mode
-      console.error('Failed to create WebGL pipeline, redirecting to Canvas2D mode:', e);
-      window.location.hash = '';
+      // WebGL pipeline creation failed - redirect to legacy Canvas2D mode
+      console.error('Failed to create WebGL pipeline, redirecting to legacy Canvas2D mode:', e);
+      window.location.hash = '#/legacy';
       return;
     }
 
@@ -669,11 +703,33 @@ export function WebGLMapPage() {
           const spriteSheets = player.getSpriteSheets();
           for (const [key, canvas] of spriteSheets) {
             const atlasName = getPlayerAtlasName(key);
+            // Surfing uses 32x32 frames, shadow uses 16x8, others use 16x32
+            let frameWidth = 16;
+            let frameHeight = 32;
+            if (key === 'shadow') {
+              frameWidth = 16;
+              frameHeight = 8;
+            } else if (key === 'surfing') {
+              frameWidth = 32;
+              frameHeight = 32;
+            }
             spriteRenderer.uploadSpriteSheet(atlasName, canvas, {
-              frameWidth: key === 'shadow' ? 16 : 16,
-              frameHeight: key === 'shadow' ? 8 : 32,
+              frameWidth,
+              frameHeight,
+            });
+            console.log(`[WebGL] Uploaded sprite sheet: ${atlasName} (${canvas.width}x${canvas.height}, frame: ${frameWidth}x${frameHeight})`);
+          }
+
+          // Upload surf blob sprite - await its loading first
+          const blobRenderer = player.getSurfingController().getBlobRenderer();
+          await blobRenderer.waitForLoad();
+          const blobCanvas = blobRenderer.getSpriteCanvas();
+          if (blobCanvas) {
+            spriteRenderer.uploadSpriteSheet('surf-blob', blobCanvas, {
+              frameWidth: 32,
+              frameHeight: 32,
             });
-            console.log(`[WebGL] Uploaded sprite sheet: ${atlasName} (${canvas.width}x${canvas.height})`);
+            console.log(`[WebGL] Uploaded surf blob sprite (${blobCanvas.width}x${blobCanvas.height})`);
           }
         }
 
@@ -1046,7 +1102,7 @@ export function WebGLMapPage() {
             }
 
             // Extract sprite groups from result
-            const { lowPrioritySprites: builtLowPriority, allSprites, priority0Sprites: builtP0, doorSprites, arrowSprite } = spriteBuildResult;
+            const { lowPrioritySprites: builtLowPriority, allSprites, priority0Sprites: builtP0, doorSprites, arrowSprite, surfBlobSprite } = spriteBuildResult;
             lowPrioritySprites = builtLowPriority;
             priority0Sprites = builtP0;
 
@@ -1190,6 +1246,7 @@ export function WebGLMapPage() {
                   priority0Sprites,
                   doorSprites,
                   arrowSprite,
+                  surfBlobSprite,
                 },
                 { fadeAlpha }
               );
@@ -1361,80 +1418,44 @@ export function WebGLMapPage() {
 
   if (!selectedMap) {
     return (
-      <div className="webgl-map-page">
-        <h1>WebGL Map Viewer</h1>
+      <div className="game-page">
+        <h1>Pkmn RSE Browser</h1>
         <p>No maps available.</p>
       </div>
     );
   }
 
-  const pixelWidth = worldSize.width;
-  const pixelHeight = worldSize.height;
-
   return (
-    <div className="webgl-map-page">
-      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline' }}>
-        <h1>WebGL Map Viewer</h1>
-        <a href="#/" style={{ color: '#88f' }}>Back to main</a>
-      </div>
-      <p style={{ marginTop: -6, color: '#ccc' }}>
-        WebGL tile rendering with player sprite. Powered by the WebGL tile renderer + palette/animation system.
-      </p>
-
-      <div className="selector">
-        <label htmlFor="map-select">Choose map</label>
-        <select
-          id="map-select"
-          value={selectedMap.id}
-          onChange={(e) => {
-            setSelectedMapId(e.target.value);
-            e.currentTarget.blur();
-          }}
-        >
-          {renderableMaps.map((map) => (
-            <option key={map.id} value={map.id}>
-              {map.name} ({map.width}x{map.height})
-            </option>
-          ))}
-        </select>
-        <div className="selector__meta">
-          <span>
-            Tilesets: {selectedMap.primaryTilesetId.replace('gTileset_', '')} / {selectedMap.secondaryTilesetId.replace('gTileset_', '')}
-          </span>
-          <span style={{ display: 'block', marginTop: 4 }}>
-            Size: {selectedMap.width}×{selectedMap.height} metatiles ({pixelWidth}×{pixelHeight}px)
-          </span>
-          {stitchedMapCount > 1 && (
-            <span style={{ display: 'block', marginTop: 4, color: '#8cf' }}>
-              Stitched: {stitchedMapCount} maps ({worldSize.width}×{worldSize.height}px world)
-            </span>
-          )}
-        </div>
-        {loading && <div style={{ marginTop: 8, color: '#88f' }}>Loading map data…</div>}
-        {stats.error && <div style={{ marginTop: 8, color: '#ff6666' }}>Error: {stats.error}</div>}
-      </div>
+    <div className="game-page">
+      <h1>Pkmn RSE Browser</h1>
+      {stats.error && <div style={{ marginBottom: 8, color: '#ff6666' }}>Error: {stats.error}</div>}
 
       <div className="map-card">
-        <div className="map-canvas-wrapper">
+        <div className="map-canvas-wrapper" style={{ position: 'relative' }}>
           <canvas
             ref={displayCanvasRef}
-            className="webgl-map-canvas"
+            className="game-canvas"
             style={{
               width: VIEWPORT_PIXEL_SIZE.width * zoom,
               height: VIEWPORT_PIXEL_SIZE.height * zoom,
               imageRendering: 'pixelated',
             }}
           />
+          {/* Dialog box overlay - positioned within viewport */}
+          <DialogBox
+            viewportWidth={VIEWPORT_PIXEL_SIZE.width * zoom}
+            viewportHeight={VIEWPORT_PIXEL_SIZE.height * zoom}
+          />
         </div>
         <div className="map-stats">
           <div style={{ fontSize: 11, color: '#9fb0cc', display: 'flex', alignItems: 'center', gap: 12 }}>
-            <span>Arrow Keys to move. Z to run. ` for debug panel.</span>
+            <span>Arrow Keys to move. Z to run. X to interact. ` for debug panel.</span>
             <span style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
               Zoom:
               {[1, 2, 3].map((z) => (
                 <button
                   key={z}
-                  onClick={() => setZoom(z)}
+                  onClick={() => onZoomChange(z)}
                   style={{
                     padding: '2px 8px',
                     fontSize: 11,
@@ -1453,15 +1474,19 @@ export function WebGLMapPage() {
         </div>
       </div>
 
-      {/* Debug Panel - slide-out sidebar with WebGL tab */}
+      {/* Debug Panel - slide-out sidebar with map selection and WebGL tab */}
       <DebugPanel
         options={debugOptions}
         onChange={setDebugOptions}
         state={debugState}
         webglState={webglDebugState}
+        maps={renderableMaps}
+        selectedMapId={selectedMapId}
+        onMapChange={setSelectedMapId}
+        mapLoading={loading}
       />
     </div>
   );
 }
 
-export default WebGLMapPage;
+export default GamePage;
diff --git a/src/App.css b/src/pages/LegacyCanvasPage.css
similarity index 98%
rename from src/App.css
rename to src/pages/LegacyCanvasPage.css
index 6456f921..d59a672f 100644
--- a/src/App.css
+++ b/src/pages/LegacyCanvasPage.css
@@ -13,7 +13,7 @@
   padding: 2rem;
 }
 
-.App {
+.legacy-canvas-page {
   display: flex;
   flex-direction: column;
   gap: 1.5rem;
diff --git a/src/App.tsx b/src/pages/LegacyCanvasPage.tsx
similarity index 78%
rename from src/App.tsx
rename to src/pages/LegacyCanvasPage.tsx
index 1bdf8283..b474b0fb 100644
--- a/src/App.tsx
+++ b/src/pages/LegacyCanvasPage.tsx
@@ -1,16 +1,25 @@
+/**
+ * Legacy Canvas Page
+ *
+ * Original Canvas 2D renderer. Kept for compatibility testing
+ * and as a fallback for browsers without WebGL2 support.
+ *
+ * Access via /#/legacy
+ */
+
 import { useMemo, useState, useRef, useCallback, type ChangeEvent } from 'react';
-import './App.css';
-import { MapRenderer, type MapRendererHandle } from './components/MapRenderer';
-import { DialogProvider } from './components/dialog';
-import type { MapIndexEntry } from './types/maps';
-import mapIndex from './data/mapIndex.json';
-import { saveManager } from './save';
+import './LegacyCanvasPage.css';
+import { MapRenderer, type MapRendererHandle } from '../components/MapRenderer';
+import { DialogProvider } from '../components/dialog';
+import type { MapIndexEntry } from '../types/maps';
+import mapIndex from '../data/mapIndex.json';
+import { saveManager } from '../save';
 
 const mapIndexData = mapIndex as MapIndexEntry[];
 
 const simplifyTilesetName = (id: string) => id.replace('gTileset_', '');
 
-function App() {
+export function LegacyCanvasPage() {
   const renderableMaps = useMemo(
     () =>
       mapIndexData.filter(
@@ -34,9 +43,9 @@ function App() {
     if (mapRendererRef.current) {
       const result = mapRendererRef.current.saveGame();
       if (result.success) {
-        console.log('[App] Game saved successfully');
+        console.log('[LegacyCanvas] Game saved successfully');
       } else {
-        console.error('[App] Save failed:', result.error);
+        console.error('[LegacyCanvas] Save failed:', result.error);
       }
     }
   }, []);
@@ -50,9 +59,9 @@ function App() {
         if (loadedMapId !== selectedMapId) {
           setSelectedMapId(loadedMapId);
         }
-        console.log('[App] Game loaded successfully');
+        console.log('[LegacyCanvas] Game loaded successfully');
       } else {
-        console.log('[App] No save data found');
+        console.log('[LegacyCanvas] No save data found');
       }
     }
   }, [selectedMapId]);
@@ -72,9 +81,9 @@ function App() {
     }
     const result = saveManager.exportToFile(0);
     if (result.success) {
-      console.log('[App] Save exported to file');
+      console.log('[LegacyCanvas] Save exported to file');
     } else {
-      console.error('[App] Export failed:', result.error);
+      console.error('[LegacyCanvas] Export failed:', result.error);
       alert('Export failed: ' + result.error);
     }
   }, []);
@@ -89,11 +98,11 @@ function App() {
 
     const result = await saveManager.importFromFile(file, 0);
     if (result.success) {
-      console.log('[App] Save loaded from file');
+      console.log('[LegacyCanvas] Save loaded from file');
       // Reload to apply imported state
       window.location.reload();
     } else {
-      console.error('[App] Import failed:', result.error);
+      console.error('[LegacyCanvas] Import failed:', result.error);
       alert('Load failed: ' + result.error);
     }
 
@@ -103,8 +112,8 @@ function App() {
 
   if (!selectedMap) {
     return (
-      <div className="App">
-        <h1>Pkmn RSE Browser</h1>
+      <div className="legacy-canvas-page">
+        <h1>Pkmn RSE Browser (Legacy)</h1>
         <p>Unable to load any maps.</p>
       </div>
     );
@@ -112,8 +121,14 @@ function App() {
 
   return (
     <DialogProvider zoom={zoom}>
-      <div className="App">
-        <h1>Pkmn RSE Browser</h1>
+      <div className="legacy-canvas-page">
+        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline' }}>
+          <h1>Pkmn RSE Browser (Legacy)</h1>
+          <a href="#/" style={{ color: '#646cff' }}>Switch to WebGL renderer</a>
+        </div>
+        <p style={{ marginTop: 0, marginBottom: '1rem', color: '#888' }}>
+          Canvas 2D renderer. For better performance, use the WebGL renderer.
+        </p>
 
         <div className="selector">
           <label htmlFor="map-select">Choose map</label>
@@ -191,4 +206,4 @@ function App() {
   );
 }
 
-export default App;
+export default LegacyCanvasPage;
diff --git a/src/pages/SurfingSpriteDebugPage.tsx b/src/pages/SurfingSpriteDebugPage.tsx
new file mode 100644
index 00000000..6d6108f4
--- /dev/null
+++ b/src/pages/SurfingSpriteDebugPage.tsx
@@ -0,0 +1,545 @@
+/**
+ * SurfingSpriteDebugPage - Debug page for surfing sprites
+ *
+ * Uses the ACTUAL WebGLSpriteRenderer from the game to reproduce any corruption.
+ * Shows all sprite states: idle, mount, dismount animations in all 4 directions.
+ */
+
+import { useEffect, useRef, useState, useCallback } from 'react';
+import { WebGLSpriteRenderer } from '../rendering/webgl/WebGLSpriteRenderer';
+import type { SpriteInstance, WorldCameraView } from '../rendering/types';
+
+// Sprite sheet info
+const SURF_BLOB_URL = '/pokeemerald/graphics/field_effects/pics/surf_blob.png';
+const SURFING_SPRITE_URL = '/pokeemerald/graphics/object_events/pics/people/brendan/surfing.png';
+const SHADOW_URL = '/pokeemerald/graphics/field_effects/pics/shadow_medium.png';
+
+const FRAME_SIZE = 32;
+const SHADOW_WIDTH = 16;
+const SHADOW_HEIGHT = 8;
+
+// Directions
+const DIRECTIONS = ['down', 'up', 'left', 'right'] as const;
+type Direction = (typeof DIRECTIONS)[number];
+
+// Blob frame mapping
+const BLOB_FRAME_MAP: Record<Direction, { atlasX: number; flip: boolean }> = {
+  down: { atlasX: 0, flip: false },
+  up: { atlasX: 0, flip: false },
+  left: { atlasX: 32, flip: false },
+  right: { atlasX: 32, flip: true },
+};
+
+// Surfing sprite idle frames: 0=down, 2=up, 4=left/right
+const SURFING_IDLE_MAP: Record<Direction, { atlasX: number; flip: boolean }> = {
+  down: { atlasX: 0, flip: false },
+  up: { atlasX: 64, flip: false },
+  left: { atlasX: 128, flip: false },
+  right: { atlasX: 128, flip: true },
+};
+
+// Surfing sprite walk/jump frames: 1=down, 3=up, 5=left/right
+const SURFING_WALK_MAP: Record<Direction, { atlasX: number; flip: boolean }> = {
+  down: { atlasX: 32, flip: false },
+  up: { atlasX: 96, flip: false },
+  left: { atlasX: 160, flip: false },
+  right: { atlasX: 160, flip: true },
+};
+
+// GBA jump Y offset table (from types.ts JUMP_Y_HIGH)
+const JUMP_Y_HIGH = [-4, -6, -8, -10, -11, -12, -12, -12, -11, -10, -9, -8, -6, -4, 0, 0];
+
+async function loadImage(url: string): Promise<HTMLCanvasElement> {
+  return new Promise((resolve, reject) => {
+    const img = new Image();
+    img.onload = () => {
+      const canvas = document.createElement('canvas');
+      canvas.width = img.width;
+      canvas.height = img.height;
+      const ctx = canvas.getContext('2d');
+      if (!ctx) {
+        reject(new Error('Failed to get canvas context'));
+        return;
+      }
+      ctx.drawImage(img, 0, 0);
+
+      // Remove background color (top-left pixel)
+      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
+      const data = imageData.data;
+      const bgR = data[0];
+      const bgG = data[1];
+      const bgB = data[2];
+
+      for (let i = 0; i < data.length; i += 4) {
+        if (data[i] === bgR && data[i + 1] === bgG && data[i + 2] === bgB) {
+          data[i + 3] = 0;
+        }
+      }
+
+      ctx.putImageData(imageData, 0, 0);
+      resolve(canvas);
+    };
+    img.onerror = reject;
+    img.src = url;
+  });
+}
+
+interface DebugInfo {
+  blobSize: string;
+  surfingSize: string;
+  webglInfo: string;
+}
+
+export function SurfingSpriteDebugPage() {
+  const canvasRef = useRef<HTMLCanvasElement>(null);
+  const canvas2dRef = useRef<HTMLCanvasElement>(null);
+  const rendererRef = useRef<WebGLSpriteRenderer | null>(null);
+  const glRef = useRef<WebGL2RenderingContext | null>(null);
+  const [loaded, setLoaded] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [debugInfo, setDebugInfo] = useState<DebugInfo | null>(null);
+  const [bobOffset, setBobOffset] = useState(0);
+  const [jumpFrame, setJumpFrame] = useState(0);
+  const [animFrame, setAnimFrame] = useState(0);
+  const spritesRef = useRef<{
+    blobCanvas: HTMLCanvasElement;
+    surfingCanvas: HTMLCanvasElement;
+    shadowCanvas: HTMLCanvasElement;
+  } | null>(null);
+
+  // Animation loop
+  useEffect(() => {
+    let bobAccum = 0;
+    let reverseAccum = 0;
+    let velocity = -1;
+    let offset = 0;
+    let jumpFrameAccum = 0;
+    let currentJumpFrame = 0;
+
+    const BOB_INTERVAL = 66.67;
+    const REVERSE_INTERVAL = 266.67;
+    const JUMP_FRAME_INTERVAL = 33.33; // ~30fps for jump animation
+
+    let lastTime = performance.now();
+
+    const animate = () => {
+      const now = performance.now();
+      const delta = now - lastTime;
+      lastTime = now;
+
+      // Bob animation
+      bobAccum += delta;
+      reverseAccum += delta;
+      while (bobAccum >= BOB_INTERVAL) {
+        bobAccum -= BOB_INTERVAL;
+        offset += velocity;
+      }
+      while (reverseAccum >= REVERSE_INTERVAL) {
+        reverseAccum -= REVERSE_INTERVAL;
+        velocity = -velocity;
+      }
+
+      // Jump frame animation (loops 0-31)
+      jumpFrameAccum += delta;
+      while (jumpFrameAccum >= JUMP_FRAME_INTERVAL) {
+        jumpFrameAccum -= JUMP_FRAME_INTERVAL;
+        currentJumpFrame = (currentJumpFrame + 1) % 32;
+      }
+
+      setBobOffset(offset);
+      setJumpFrame(currentJumpFrame);
+      setAnimFrame((f) => f + 1);
+      requestAnimationFrame(animate);
+    };
+
+    const id = requestAnimationFrame(animate);
+    return () => cancelAnimationFrame(id);
+  }, []);
+
+  const render = useCallback(() => {
+    const canvas = canvasRef.current;
+    const canvas2d = canvas2dRef.current;
+    const renderer = rendererRef.current;
+    const sprites = spritesRef.current;
+    const gl = glRef.current;
+
+    if (!canvas || !canvas2d || !renderer || !sprites || !gl) return;
+
+    const ctx2d = canvas2d.getContext('2d');
+    if (!ctx2d) return;
+
+    // Clear and draw checkerboard
+    ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
+    const checkerSize = 8;
+    for (let cy = 0; cy < canvas2d.height; cy += checkerSize) {
+      for (let cx = 0; cx < canvas2d.width; cx += checkerSize) {
+        ctx2d.fillStyle = ((cx / checkerSize) + (cy / checkerSize)) % 2 === 0 ? '#444' : '#333';
+        ctx2d.fillRect(cx, cy, checkerSize, checkerSize);
+      }
+    }
+
+    ctx2d.fillStyle = '#fff';
+    ctx2d.font = 'bold 12px monospace';
+
+    const scale = 2;
+    const spriteW = FRAME_SIZE * scale;
+    const spriteH = FRAME_SIZE * scale;
+    const colWidth = spriteW + 15;
+
+    // Camera view
+    const view: WorldCameraView = {
+      cameraX: 0, cameraY: 0,
+      startTileX: 0, startTileY: 0,
+      subTileOffsetX: 0, subTileOffsetY: 0,
+      tilesWide: Math.ceil(canvas.width / 16),
+      tilesHigh: Math.ceil(canvas.height / 16),
+      pixelWidth: canvas.width, pixelHeight: canvas.height,
+      worldStartTileX: 0, worldStartTileY: 0,
+      cameraWorldX: 0, cameraWorldY: 0,
+    };
+
+    gl.viewport(0, 0, canvas.width, canvas.height);
+    gl.clearColor(0, 0, 0, 0);
+    gl.clear(gl.COLOR_BUFFER_BIT);
+
+    const allSprites: SpriteInstance[] = [];
+    let sortKey = 0;
+
+    const addSprite = (
+      atlasName: string,
+      atlasX: number,
+      worldX: number,
+      worldY: number,
+      flip: boolean,
+      width?: number,
+      height?: number,
+      atlasWidth?: number,
+      atlasHeight?: number
+    ) => {
+      allSprites.push({
+        worldX, worldY,
+        width: width ?? spriteW, height: height ?? spriteH,
+        atlasName,
+        atlasX, atlasY: 0,
+        atlasWidth: atlasWidth ?? FRAME_SIZE, atlasHeight: atlasHeight ?? FRAME_SIZE,
+        flipX: flip, flipY: false,
+        alpha: 1.0, tintR: 1.0, tintG: 1.0, tintB: 1.0,
+        sortKey: sortKey++,
+        isReflection: false,
+      });
+    };
+
+    const addShadow = (worldX: number, worldY: number) => {
+      // Shadow is 16x8, positioned below player feet
+      const shadowW = SHADOW_WIDTH * scale;
+      const shadowH = SHADOW_HEIGHT * scale;
+      // Center shadow under 32px sprite, offset down by ~28px (scaled)
+      const shadowX = worldX + (spriteW - shadowW) / 2;
+      const shadowY = worldY + 28 * scale;
+      addSprite('shadow', 0, shadowX, shadowY, false, shadowW, shadowH, SHADOW_WIDTH, SHADOW_HEIGHT);
+    };
+
+    // Jump Y offset for current frame
+    const jumpYIndex = Math.min(15, jumpFrame >> 1);
+    const jumpYOffset = JUMP_Y_HIGH[jumpYIndex] * scale;
+    // Jump X progress (0 to 16px over 32 frames)
+    const jumpXProgress = Math.floor((jumpFrame / 32) * 16) * scale;
+
+    let y = 10;
+    const leftMargin = 15;
+    const rowGap = 20;
+
+    // === ROW 1: Raw blob sprite sheet ===
+    ctx2d.fillText('RAW BLOB (96x32) - 3 frames:', leftMargin, y + 12);
+    let x = leftMargin + 200;
+    const blobLabels = ['0: D/U', '1: L', '2: ?'];
+    for (let i = 0; i < 3; i++) {
+      ctx2d.font = '9px monospace';
+      ctx2d.fillStyle = '#888';
+      ctx2d.fillText(blobLabels[i], x + 12, y + 5);
+      addSprite('surf-blob', i * FRAME_SIZE, x, y + 8, false);
+      x += spriteW + 20;
+    }
+    ctx2d.fillStyle = '#fff';
+    ctx2d.font = 'bold 12px monospace';
+    y += spriteH + rowGap + 5;
+
+    // === ROW 2: Raw surfing sprite sheet ===
+    ctx2d.fillText('RAW SURFING (192x32) - 6 frames:', leftMargin, y + 12);
+    x = leftMargin + 220;
+    const surfLabels = ['0: D', '1: D-w', '2: U', '3: U-w', '4: L', '5: L-w'];
+    for (let i = 0; i < 6; i++) {
+      ctx2d.font = '9px monospace';
+      ctx2d.fillStyle = '#888';
+      ctx2d.fillText(surfLabels[i], x + 8, y + 5);
+      addSprite('player-surfing', i * FRAME_SIZE, x, y + 8, false);
+      x += spriteW + 15;
+    }
+    ctx2d.fillStyle = '#fff';
+    ctx2d.font = 'bold 12px monospace';
+    y += spriteH + rowGap + 10;
+
+    // === ROW 3: Direction labels ===
+    ctx2d.font = '10px monospace';
+    ctx2d.fillStyle = '#888';
+    x = leftMargin + 60;
+    for (const dir of DIRECTIONS) {
+      ctx2d.fillText(dir.toUpperCase(), x + spriteW / 2 - 12, y);
+      x += colWidth;
+    }
+    ctx2d.fillText('|', x + 5, y);
+    x += 50;
+    for (const dir of DIRECTIONS) {
+      ctx2d.fillText(dir.toUpperCase(), x + spriteW / 2 - 12, y);
+      x += colWidth;
+    }
+    y += 15;
+    ctx2d.fillStyle = '#fff';
+    ctx2d.font = 'bold 12px monospace';
+
+    // === ROW 4: Blob + Idle surfing by direction ===
+    ctx2d.fillText('BLOB:', leftMargin, y + spriteH / 2);
+    x = leftMargin + 60;
+    for (const dir of DIRECTIONS) {
+      const { atlasX, flip } = BLOB_FRAME_MAP[dir];
+      addSprite('surf-blob', atlasX, x, y, flip);
+      x += colWidth;
+    }
+    ctx2d.fillText('IDLE:', x + 10, y + spriteH / 2);
+    x += 50;
+    for (const dir of DIRECTIONS) {
+      const { atlasX, flip } = SURFING_IDLE_MAP[dir];
+      addSprite('player-surfing', atlasX, x, y, flip);
+      x += colWidth;
+    }
+    y += spriteH + rowGap;
+
+    // === ROW 5: Walk/Jump frames ===
+    ctx2d.fillText('WALK:', leftMargin, y + spriteH / 2);
+    x = leftMargin + 60;
+    for (const dir of DIRECTIONS) {
+      const { atlasX, flip } = SURFING_WALK_MAP[dir];
+      addSprite('player-surfing', atlasX, x, y, flip);
+      x += colWidth;
+    }
+    y += spriteH + rowGap + 5;
+
+    // === ROW 6: SURFING IDLE (combined, bobbing) ===
+    ctx2d.fillText(`SURFING (bob: ${bobOffset}px):`, leftMargin, y + 15);
+    x = leftMargin + 180;
+    for (const dir of DIRECTIONS) {
+      const blob = BLOB_FRAME_MAP[dir];
+      const surf = SURFING_IDLE_MAP[dir];
+      // Blob behind with bob
+      addSprite('surf-blob', blob.atlasX, x, y + 8 * scale + bobOffset * scale, blob.flip);
+      // Player with bob
+      addSprite('player-surfing', surf.atlasX, x, y + bobOffset * scale, surf.flip);
+      x += colWidth + 15;
+    }
+    y += spriteH + rowGap + 15;
+
+    // === ROW 7: MOUNT animation (jump onto blob) with shadow ===
+    ctx2d.fillText(`MOUNT (f${jumpFrame}):`, leftMargin, y + 20);
+    x = leftMargin + 120;
+    for (const dir of DIRECTIONS) {
+      const blob = BLOB_FRAME_MAP[dir];
+      const surf = SURFING_WALK_MAP[dir]; // Walk frame during jump
+
+      // Calculate direction offset
+      let dx = 0, dy = 0;
+      if (dir === 'down') dy = 1;
+      else if (dir === 'up') dy = -1;
+      else if (dir === 'left') dx = -1;
+      else if (dir === 'right') dx = 1;
+
+      // Blob at destination (stationary, no bob during mount)
+      const blobX = x + dx * 16 * scale;
+      const blobY = y + dy * 16 * scale + 8 * scale;
+      addSprite('surf-blob', blob.atlasX, blobX, blobY, blob.flip);
+
+      // Player jumping from start toward blob
+      const playerX = x + dx * jumpXProgress;
+      const playerY = y + dy * jumpXProgress + jumpYOffset;
+
+      // Shadow stays on ground (no Y offset from jump)
+      addShadow(x + dx * jumpXProgress, y + dy * jumpXProgress);
+      addSprite('player-surfing', surf.atlasX, playerX, playerY, surf.flip);
+
+      x += colWidth + 50;
+    }
+    y += spriteH + rowGap + 45;
+
+    // === ROW 8: DISMOUNT animation (jump off blob) with shadow ===
+    ctx2d.fillText(`DISMOUNT (f${jumpFrame}):`, leftMargin, y + 20);
+    x = leftMargin + 120;
+    for (const dir of DIRECTIONS) {
+      const blob = BLOB_FRAME_MAP[dir];
+      const surf = SURFING_WALK_MAP[dir];
+
+      let dx = 0, dy = 0;
+      if (dir === 'down') dy = 1;
+      else if (dir === 'up') dy = -1;
+      else if (dir === 'left') dx = -1;
+      else if (dir === 'right') dx = 1;
+
+      // Blob stays at start position (with bob during dismount)
+      addSprite('surf-blob', blob.atlasX, x, y + 8 * scale + bobOffset * scale, blob.flip);
+
+      // Player jumping away from blob
+      const playerX = x + dx * jumpXProgress;
+      const playerY = y + dy * jumpXProgress + jumpYOffset;
+
+      // Shadow at landing position (no Y offset from jump)
+      addShadow(x + dx * jumpXProgress, y + dy * jumpXProgress);
+      addSprite('player-surfing', surf.atlasX, playerX, playerY, surf.flip);
+
+      x += colWidth + 50;
+    }
+
+    // Render all
+    renderer.renderBatch(allSprites, view);
+    ctx2d.drawImage(canvas, 0, 0);
+
+    // Draw jump Y offset graph (bottom right)
+    const graphX = 700;
+    const graphY = 680;
+    ctx2d.fillStyle = '#222';
+    ctx2d.fillRect(graphX, graphY, 160, 80);
+    ctx2d.strokeStyle = '#666';
+    ctx2d.strokeRect(graphX, graphY, 160, 80);
+
+    ctx2d.fillStyle = '#888';
+    ctx2d.font = '10px monospace';
+    ctx2d.fillText('Jump Y Offset', graphX + 5, graphY + 12);
+    ctx2d.fillText('0', graphX - 8, graphY + 40);
+    ctx2d.fillText('-12', graphX - 20, graphY + 15);
+
+    ctx2d.strokeStyle = '#4a4';
+    ctx2d.beginPath();
+    for (let i = 0; i < 16; i++) {
+      const gx = graphX + 10 + i * 9;
+      const gy = graphY + 40 + JUMP_Y_HIGH[i] * 2.5;
+      if (i === 0) ctx2d.moveTo(gx, gy);
+      else ctx2d.lineTo(gx, gy);
+    }
+    ctx2d.stroke();
+
+    // Current frame marker
+    const markerX = graphX + 10 + jumpYIndex * 9;
+    const markerY = graphY + 40 + JUMP_Y_HIGH[jumpYIndex] * 2.5;
+    ctx2d.fillStyle = '#f55';
+    ctx2d.beginPath();
+    ctx2d.arc(markerX, markerY, 4, 0, Math.PI * 2);
+    ctx2d.fill();
+
+  }, [bobOffset, jumpFrame]);
+
+  useEffect(() => {
+    render();
+  }, [render, animFrame]);
+
+  useEffect(() => {
+    const canvas = canvasRef.current;
+    const canvas2d = canvas2dRef.current;
+    if (!canvas || !canvas2d) return;
+
+    const gl = canvas.getContext('webgl2', {
+      alpha: true,
+      premultipliedAlpha: false,
+      antialias: false,
+      preserveDrawingBuffer: true,
+    });
+
+    if (!gl) {
+      setError('WebGL2 not supported');
+      return;
+    }
+
+    const init = async () => {
+      try {
+        glRef.current = gl;
+        const renderer = new WebGLSpriteRenderer(gl);
+        renderer.initialize();
+        rendererRef.current = renderer;
+
+        const [blobCanvas, surfingCanvas, shadowCanvas] = await Promise.all([
+          loadImage(SURF_BLOB_URL),
+          loadImage(SURFING_SPRITE_URL),
+          loadImage(SHADOW_URL),
+        ]);
+
+        spritesRef.current = { blobCanvas, surfingCanvas, shadowCanvas };
+
+        renderer.uploadSpriteSheet('surf-blob', blobCanvas, { frameWidth: 32, frameHeight: 32 });
+        renderer.uploadSpriteSheet('player-surfing', surfingCanvas, { frameWidth: 32, frameHeight: 32 });
+        renderer.uploadSpriteSheet('shadow', shadowCanvas, { frameWidth: SHADOW_WIDTH, frameHeight: SHADOW_HEIGHT });
+
+        setDebugInfo({
+          blobSize: `${blobCanvas.width}x${blobCanvas.height}`,
+          surfingSize: `${surfingCanvas.width}x${surfingCanvas.height}`,
+          webglInfo: `${gl.getParameter(gl.RENDERER)}`,
+        });
+
+        setLoaded(true);
+      } catch (err) {
+        setError(err instanceof Error ? err.message : 'Unknown error');
+      }
+    };
+
+    init();
+    return () => {
+      rendererRef.current?.dispose();
+      rendererRef.current = null;
+    };
+  }, []);
+
+  return (
+    <div style={{ backgroundColor: '#1a1a2e', minHeight: '100vh', padding: 15, color: '#fff', fontFamily: 'monospace' }}>
+      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 10 }}>
+        <div>
+          <h1 style={{ margin: 0, fontSize: 18 }}>Surfing Sprite Debug (WebGLSpriteRenderer)</h1>
+          <p style={{ margin: '5px 0 0', color: '#888', fontSize: 11 }}>
+            Uses actual game renderer - if corruption appears here, it will appear in game
+          </p>
+        </div>
+        {debugInfo && (
+          <div style={{ fontSize: 10, color: '#888', textAlign: 'right' }}>
+            <div>blob: {debugInfo.blobSize} | surfing: {debugInfo.surfingSize}</div>
+            <div>{debugInfo.webglInfo}</div>
+          </div>
+        )}
+      </div>
+
+      {error && <div style={{ color: '#ff6b6b', marginBottom: 10 }}>Error: {error}</div>}
+
+      <div style={{ display: 'flex', gap: 20 }}>
+        <div>
+          <canvas ref={canvasRef} width={900} height={780} style={{ display: 'none' }} />
+          <canvas ref={canvas2dRef} width={900} height={780} style={{ border: '1px solid #444' }} />
+        </div>
+
+        <div style={{ width: 280, fontSize: 11, lineHeight: 1.5 }}>
+          <h3 style={{ margin: '0 0 8px', fontSize: 13 }}>Potential Corruption Causes</h3>
+          <div style={{ color: '#aaa' }}>
+            <p><strong>1. Texture bleeding:</strong> UV coords sample adjacent frames at boundaries</p>
+            <p><strong>2. Wrong frame size:</strong> Upload uses 32x32 but render uses different</p>
+            <p><strong>3. Premultiplied alpha:</strong> Canvas2D/WebGL mismatch causes edge artifacts</p>
+            <p><strong>4. Non-integer positions:</strong> Subpixel coords + filtering = blur</p>
+            <p><strong>5. Float UV precision:</strong> Rounding errors cause 1px shifts</p>
+          </div>
+
+          <h3 style={{ margin: '15px 0 8px', fontSize: 13 }}>Frame Info</h3>
+          <div style={{ color: '#aaa' }}>
+            <p><strong>Blob:</strong> 3 frames (96x32). 0=down/up, 1=left, 1-flip=right</p>
+            <p><strong>Surfing:</strong> 6 frames (192x32). Even=idle, Odd=walk/jump</p>
+            <p><strong>Mount:</strong> Player uses walk frame, jumps TO blob (no bob)</p>
+            <p><strong>Dismount:</strong> Player uses walk frame, jumps FROM blob (blob bobs)</p>
+            <p><strong>Jump arc:</strong> 32 frames, Y peaks at -12px around frame 12</p>
+          </div>
+        </div>
+      </div>
+
+      {!loaded && !error && <div style={{ marginTop: 10 }}>Loading...</div>}
+    </div>
+  );
+}
diff --git a/src/rendering/MapBackingStore.ts b/src/rendering/MapBackingStore.ts
index d175acea..bb038d16 100644
--- a/src/rendering/MapBackingStore.ts
+++ b/src/rendering/MapBackingStore.ts
@@ -101,6 +101,13 @@ export class MapBackingStore {
     }
   }
 
+  /**
+   * Clear all cached chunks. Call when switching maps to free memory.
+   */
+  clear(): void {
+    this.chunks.clear();
+  }
+
   /**
    * Get or render a chunk for a specific pass
    *
diff --git a/src/rendering/RendererFactory.ts b/src/rendering/RendererFactory.ts
new file mode 100644
index 00000000..e7b4bfd5
--- /dev/null
+++ b/src/rendering/RendererFactory.ts
@@ -0,0 +1,177 @@
+/**
+ * RendererFactory - Creates complete renderer sets for game rendering
+ *
+ * Wraps RenderPipelineFactory and creates sprite/fade renderers to provide
+ * a complete rendering backend.
+ */
+
+import { RenderPipelineFactory, type RenderPipelineFactoryResult } from './RenderPipelineFactory';
+import { WebGLSpriteRenderer } from './webgl/WebGLSpriteRenderer';
+import { WebGLFadeRenderer } from './webgl/WebGLFadeRenderer';
+import { WebGLRenderPipeline } from './webgl/WebGLRenderPipeline';
+import { Canvas2DSpriteRenderer } from './Canvas2DSpriteRenderer';
+import { Canvas2DFadeRenderer } from './Canvas2DFadeRenderer';
+import type { IRenderPipeline, RendererType } from './IRenderPipeline';
+import type { ISpriteRenderer } from './ISpriteRenderer';
+import type { IFadeRenderer } from './IFadeRenderer';
+
+export type { RendererType };
+
+export interface RendererSet {
+  type: RendererType;
+  pipeline: IRenderPipeline;
+  spriteRenderer: ISpriteRenderer;
+  fadeRenderer: IFadeRenderer;
+  /** WebGL canvas (only for WebGL renderer) */
+  webglCanvas: HTMLCanvasElement | null;
+  /** For WebGL: access to underlying WebGLRenderPipeline */
+  getWebGLPipeline?: () => WebGLRenderPipeline;
+  /** Dispose all renderers */
+  dispose: () => void;
+}
+
+export interface RendererFactoryOptions {
+  /** Force a specific renderer type (skips auto-detection) */
+  forceType?: RendererType;
+  /** Viewport dimensions */
+  viewportWidth: number;
+  viewportHeight: number;
+}
+
+/**
+ * Detect the best available renderer type
+ */
+export function detectRendererType(): RendererType {
+  const testCanvas = document.createElement('canvas');
+  testCanvas.width = 1;
+  testCanvas.height = 1;
+  return RenderPipelineFactory.supportsWebGL2(testCanvas) ? 'webgl' : 'canvas2d';
+}
+
+/**
+ * Create a complete renderer set
+ */
+export function createRenderers(options: RendererFactoryOptions): RendererSet {
+  const { forceType, viewportWidth, viewportHeight } = options;
+  const type = forceType ?? detectRendererType();
+
+  if (type === 'webgl') {
+    return createWebGLRenderers(viewportWidth, viewportHeight);
+  } else {
+    return createCanvas2DRenderers(viewportWidth, viewportHeight);
+  }
+}
+
+/**
+ * Create WebGL renderer set
+ */
+function createWebGLRenderers(
+  viewportWidth: number,
+  viewportHeight: number
+): RendererSet {
+  // Create WebGL canvas
+  const webglCanvas = document.createElement('canvas');
+  webglCanvas.width = viewportWidth;
+  webglCanvas.height = viewportHeight;
+
+  console.log('[RendererFactory] Creating WebGL pipeline, canvas:', viewportWidth, 'x', viewportHeight);
+
+  // Create pipeline using factory
+  let pipelineResult: RenderPipelineFactoryResult;
+  try {
+    pipelineResult = RenderPipelineFactory.create(webglCanvas, {
+      preferWebGL: true,
+    });
+    console.log('[RendererFactory] Pipeline created, type:', pipelineResult.rendererType);
+  } catch (e) {
+    console.error('[RendererFactory] Pipeline creation threw:', e);
+    return createCanvas2DRenderers(viewportWidth, viewportHeight);
+  }
+
+  if (pipelineResult.rendererType !== 'webgl') {
+    // WebGL failed, fall back to Canvas2D
+    console.warn('[RendererFactory] WebGL not available, falling back to Canvas2D');
+    return createCanvas2DRenderers(viewportWidth, viewportHeight);
+  }
+
+  // Get the underlying WebGL pipeline to access GL context
+  const webglAdapter = pipelineResult.pipeline as ReturnType<typeof RenderPipelineFactory.createWebGL>;
+  const webglPipeline = webglAdapter.getUnderlyingPipeline();
+  const gl = webglPipeline.getGL();
+
+  // Create and initialize sprite renderer
+  const spriteRenderer = new WebGLSpriteRenderer(gl);
+  spriteRenderer.initialize();
+
+  // Create and initialize fade renderer
+  const fadeRenderer = new WebGLFadeRenderer(gl);
+  fadeRenderer.initialize();
+
+  return {
+    type: 'webgl',
+    pipeline: pipelineResult.pipeline,
+    spriteRenderer,
+    fadeRenderer,
+    webglCanvas,
+    getWebGLPipeline: () => webglPipeline,
+    dispose: () => {
+      pipelineResult.pipeline.dispose();
+      spriteRenderer.dispose();
+      fadeRenderer.dispose();
+    },
+  };
+}
+
+/**
+ * Create Canvas2D renderer set
+ */
+function createCanvas2DRenderers(
+  viewportWidth: number,
+  viewportHeight: number
+): RendererSet {
+  // Create offscreen canvas for rendering
+  const offscreenCanvas = document.createElement('canvas');
+  offscreenCanvas.width = viewportWidth;
+  offscreenCanvas.height = viewportHeight;
+
+  const ctx = offscreenCanvas.getContext('2d');
+  if (!ctx) {
+    throw new Error('Failed to get 2D context');
+  }
+
+  // Create pipeline using factory
+  const pipelineResult = RenderPipelineFactory.create(undefined, {
+    preferWebGL: false,
+  });
+
+  // Create sprite renderer
+  const spriteRenderer = new Canvas2DSpriteRenderer(ctx);
+
+  // Create fade renderer
+  const fadeRenderer = new Canvas2DFadeRenderer(ctx, viewportWidth, viewportHeight);
+
+  return {
+    type: 'canvas2d',
+    pipeline: pipelineResult.pipeline,
+    spriteRenderer,
+    fadeRenderer,
+    webglCanvas: null,
+    dispose: () => {
+      pipelineResult.pipeline.dispose();
+      spriteRenderer.dispose();
+      fadeRenderer.dispose();
+    },
+  };
+}
+
+/**
+ * Get renderer type from URL query param
+ */
+export function getRendererTypeFromURL(): RendererType | null {
+  const params = new URLSearchParams(window.location.search);
+  const renderer = params.get('renderer');
+  if (renderer === 'webgl' || renderer === 'canvas2d') {
+    return renderer;
+  }
+  return null;
+}
diff --git a/src/rendering/compositeWebGLFrame.ts b/src/rendering/compositeWebGLFrame.ts
index dbdffb25..6d0f1b73 100644
--- a/src/rendering/compositeWebGLFrame.ts
+++ b/src/rendering/compositeWebGLFrame.ts
@@ -56,6 +56,8 @@ export interface SpriteGroups {
   doorSprites: SpriteInstance[];
   /** Arrow overlay sprite */
   arrowSprite: SpriteInstance | null;
+  /** Surf blob sprite (rendered behind player) */
+  surfBlobSprite?: SpriteInstance | null;
 }
 
 export interface CompositeFrameOptions {
@@ -87,14 +89,19 @@ export function compositeWebGLFrame(
   options: CompositeFrameOptions
 ): void {
   const { pipeline, spriteRenderer, fadeRenderer, ctx2d, webglCanvas, view, snapshot, tilesetRuntimes } = ctx;
-  const { lowPrioritySprites, allSprites, priority0Sprites, doorSprites, arrowSprite } = sprites;
+  const { lowPrioritySprites, allSprites, priority0Sprites, doorSprites, arrowSprite, surfBlobSprite } = sprites;
   const { fadeAlpha } = options;
 
   const gl = pipeline.getGL();
 
+  // Add surf blob to main sprites (it will be sorted by sortKey to render behind player)
+  const allSpritesWithBlob = surfBlobSprite ? [...allSprites, surfBlobSprite] : allSprites;
+  // Re-sort to ensure surf blob is in correct position
+  allSpritesWithBlob.sort((a, b) => a.sortKey - b.sortKey);
+
   // Split sprites into reflection-layer and normal
-  const reflectionLayerSprites = allSprites.filter((s) => s.isReflection || s.isReflectionLayer);
-  const normalSprites = allSprites.filter((s) => !s.isReflection && !s.isReflectionLayer);
+  const reflectionLayerSprites = allSpritesWithBlob.filter((s) => s.isReflection || s.isReflectionLayer);
+  const normalSprites = allSpritesWithBlob.filter((s) => !s.isReflection && !s.isReflectionLayer);
   const lowPriorityReflections = lowPrioritySprites.filter((s) => s.isReflection || s.isReflectionLayer);
   const normalLowPrioritySprites = lowPrioritySprites.filter((s) => !s.isReflection && !s.isReflectionLayer);
 
